<!-- Compiled in Cursor | Last build update: 2/7/2026  5:38:56 PM | Version No. 5 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strike Maps</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@500;600;700;800&display=swap" rel="stylesheet">
    <link rel="icon" href="https://strike-bot.pages.dev/strike.jpg">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        :root {
            --bg: #000000;
            --glass-surface: rgba(10, 10, 10, 0.85);
            --glass-border: rgba(255, 255, 255, 0.08);
            --font-main: 'Manrope', sans-serif;
            --ease-pro: cubic-bezier(0.2, 0, 0, 1);
        }

        body, html { margin: 0; padding: 0; background: var(--bg); color: #fff; font-family: var(--font-main); height: 100vh; width: 100vw; overflow: hidden; }

        #map { height: 100%; width: 100%; z-index: 1; background: #050505; transition: opacity 1s ease; }
        .dark-layer { filter: invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%); }
        
        .strike-glass { background: var(--glass-surface); backdrop-filter: blur(30px); border: 1px solid var(--glass-border); box-shadow: 0 24px 60px rgba(0,0,0,0.9); border-radius: 16px; }
        .strike-input { background: rgba(255,255,255,0.03); border: 1px solid var(--glass-border); color: white; transition: all 0.3s var(--ease-pro); }

        #info-sidebar { position: absolute; right: 24px; top: 24px; bottom: 24px; width: 380px; z-index: 2000; transform: translateX(calc(100% + 50px)); transition: transform 0.8s var(--ease-pro); display: flex; flex-direction: column; }
        #info-sidebar.active { transform: translateX(0); }

        .route-card { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); padding: 12px; border-radius: 12px; transition: all 0.2s; cursor: pointer; }
        .route-card.active { border-color: #ffffff; background: rgba(255, 255, 255, 0.05); }

        /* ACTIVE NAV HUD */
        #active-nav-hud { display: none; }
        
        #loader { position: fixed; inset: 0; z-index: 9999; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; }
        .loading-bar { width: 120px; height: 2px; background: #111; margin-top: 15px; position: relative; overflow: hidden; }
        .loading-fill { position: absolute; left: 0; top: 0; height: 100%; background: #fff; width: 0%; animation: load 2s forwards; }
        @keyframes load { to { width: 100%; } }

        .ui-animate { opacity: 0; transform: translateY(15px); transition: all 0.8s var(--ease-pro); }
        .ui-ready .ui-animate { opacity: 1; transform: translateY(0); }
        
        .gps-ring { 
            border: 2px solid #fff; 
            border-radius: 50%; 
            height: 18px; 
            width: 18px; 
            box-shadow: 0 0 15px rgba(255,255,255,0.6); 
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Search results and filters */
        #results { max-height: 250px; overflow-y: auto; }
        #results::-webkit-scrollbar { width: 4px; }
        #results::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 2px; }
        #results::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        /* Directions list scrollbar */
        #sidebar-content::-webkit-scrollbar { width: 4px; }
        #sidebar-content::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 2px; }
        #sidebar-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        /* Directions list specific */
        #directions-list { max-height: 500px; overflow-y: auto; }
        #directions-list::-webkit-scrollbar { width: 4px; }
        #directions-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 2px; }
        #directions-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        .search-result { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; transition: all 0.2s; }
        .search-result:hover { background: rgba(255,255,255,0.05); }
        .search-result:last-child { border-bottom: none; }
        
        .filter-btn { padding: 6px 10px; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; font-size: 10px; font-weight: 600; background: rgba(255,255,255,0.03); color: rgba(255,255,255,0.7); transition: all 0.2s; }
        .filter-btn.active { background: rgba(255,255,255,0.1); color: white; border-color: rgba(255,255,255,0.3); }
        
        /* Navigation instructions */
        .nav-instruction-text { font-size: 13px; line-height: 1.4; }
        
        /* Exit navigation button */
        #exit-nav-btn { background: rgba(239, 68, 68, 0.25); border: 1px solid rgba(239, 68, 68, 0.5); color: #ff6b6b; }
        #exit-nav-btn:hover { background: #ef4444; color: white; border-color: #ef4444; }
        
        /* Path styling */
        .aviation-path { stroke-dasharray: 10, 10; }
        
        /* Type badges */
        .type-badge { 
            font-size: 8px; 
            font-weight: 700; 
            padding: 2px 5px; 
            border-radius: 4px; 
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .type-city { background: rgba(59, 130, 246, 0.2); color: #93c5fd; }
        .type-street { background: rgba(139, 92, 246, 0.2); color: #c4b5fd; }
        .type-building { background: rgba(239, 68, 68, 0.2); color: #fca5a5; }
        .type-landmark { background: rgba(245, 158, 11, 0.2); color: #fcd34d; }
        .type-default { background: rgba(255, 255, 255, 0.1); color: rgba(255, 255, 255, 0.7); }
        
        /* Directions list */
        .direction-item { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); transition: all 0.3s; }
        .direction-item.active { background: rgba(59, 130, 246, 0.15); border-left: 3px solid #3b82f6; }
        .direction-item.completed { opacity: 0.5; }
        
        /* Traffic indicators */
        .traffic-indicator { 
            display: inline-block; 
            width: 6px; 
            height: 6px; 
            border-radius: 50%; 
            margin-right: 4px;
        }
        .traffic-high { background: #ef4444; }
        .traffic-medium { background: #f59e0b; }
        .traffic-low { background: #10b981; }
        
        /* Recents list */
        .recent-item { padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; }
        .recent-item:hover { background: rgba(255,255,255,0.05); }
        .recent-time { font-size: 9px; color: #6b7280; }
        
        /* Progress bar */
        .progress-bar { height: 3px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; margin-top: 8px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #10b981, #3b82f6); transition: width 0.3s; }
        
        /* Step numbers */
        .step-number { 
            width: 24px; 
            height: 24px; 
            border-radius: 50%; 
            background: rgba(255,255,255,0.1); 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 11px; 
            font-weight: 700;
        }
        .step-number.active { background: #3b82f6; color: white; }
        .step-number.completed { background: #10b981; color: white; }
        .step-content { flex: 1; }
        .step-instruction { font-size: 12px; font-weight: 600; color: white; }
        .step-details { font-size: 10px; color: #9ca3af; margin-top: 2px; }
        
        /* HUD elements */
        .nav-hud-pos { display: block; }
        .nav-hud-eta { display: none; }
        .nav-hud-acc { display: block; }
        .nav-hud-distance { display: none; }
        
        /* When navigating */
        body.navigating .nav-hud-pos { display: none; }
        body.navigating .nav-hud-eta { display: block; }
        body.navigating .nav-hud-acc { display: none; }
        body.navigating .nav-hud-distance { display: block; }

#directions-list::-webkit-scrollbar { width: 4px; }
#directions-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 2px; }
#directions-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }

.nav-hud-pos { display: block; }
.nav-hud-eta { display: none; }
.nav-hud-acc { display: block; }
.nav-hud-distance { display: none; }

body.navigating .nav-hud-pos { display: none; }
body.navigating .nav-hud-eta { display: block; }
body.navigating .nav-hud-acc { display: none; }
body.navigating .nav-hud-distance { display: block; }

.nav-hud-pos::before { content: "Pos  "; }
.nav-hud-eta::before { content: "ETA  "; } 
.nav-hud-acc::before { content: "Acc  "; }
.nav-hud-distance::before { content: "Left  "; } 

/* Custom start point UI */
#custom-start-panel {
    position: absolute;
    top: 80px;
    left: 24px;
    z-index: 1001;
    width: 340px;
}

#custom-start-toggle {
    width: 100%;
    padding: 8px 12px;
    font-size: 11px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: #9ca3af;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

#custom-start-toggle:hover {
    background: rgba(255,255,255,0.05);
    color: white;
}

#custom-start-expanded {
    display: none;
    margin-top: 8px;
    padding: 16px;
}

.start-mode-btn {
    width: 100%;
    padding: 10px;
    margin-bottom: 8px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: white;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.2s;
}

.start-mode-btn:hover {
    background: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.2);
}

.start-mode-btn.active {
    background: rgba(59, 130, 246, 0.2);
    border-color: #3b82f6;
    color: #93c5fd;
}

#custom-start-input-container {
    display: none;
    margin-top: 12px;
}

#custom-start-search-results {
    max-height: 200px;
    overflow-y: auto;
    margin-top: 8px;
    display: none;
}

.current-start-display {
    font-size: 10px;
    color: #9ca3af;
    margin-top: 4px;
    padding: 8px;
    background: rgba(255,255,255,0.02);
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.05);
}

/* Custom start point UI */
#custom-start-panel {
    position: absolute;
    top: 180px;
    left: 24px;
    z-index: 1001;
    width: 340px;
}

#custom-start-toggle {
    width: 100%;
    padding: 8px 12px;
    font-size: 11px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: #9ca3af;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

#custom-start-toggle:hover {
    background: rgba(255,255,255,0.05);
    color: white;
}

#custom-start-expanded {
    display: none;
    margin-top: 8px;
    padding: 16px;
}

.start-mode-btn {
    width: 100%;
    padding: 10px;
    margin-bottom: 8px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: white;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.2s;
}

.start-mode-btn:hover {
    background: rgba(255,255,255,0.05);
    border-color: rgba(255,255,255,0.2);
}

.start-mode-btn.active {
    background: rgba(59, 130, 246, 0.2);
    border-color: #3b82f6;
    color: #93c5fd;
}

#custom-start-input-container {
    display: none;
    margin-top: 12px;
}

#custom-start-search-results {
    max-height: 200px;
    overflow-y: auto;
    margin-top: 8px;
    display: none;
}

.current-start-display {
    font-size: 10px;
    color: #9ca3af;
    margin-top: 4px;
    padding: 8px;
    background: rgba(255,255,255,0.02);
    border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.05);
}

/* Custom start point UI - FIXED HEIGHT AND SCROLLING */
#custom-start-panel {
    position: absolute;
    top: 180px; /* Moved down below the Signal State panel */
    left: 24px;
    z-index: 999; /* LOWER than search panel (1000) */
    width: 340px;
    pointer-events: auto; /* Ensure it's clickable */
}

#custom-start-toggle {
    width: 100%;
    padding: 8px 12px;
    font-size: 11px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    color: #9ca3af;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

#custom-start-toggle:hover {
    background: rgba(255,255,255,0.05);
    color: white;
}

#custom-start-expanded {
    display: none;
    margin-top: 8px;
    padding: 16px;
    background: var(--glass-surface);
    backdrop-filter: blur(30px);
    border: 1px solid var(--glass-border);
    border-radius: 12px;
    box-shadow: 0 24px 60px rgba(0,0,0,0.9);
    overflow-y: auto; /* Always scrollable */
}

/* DYNAMIC HEIGHT CALCULATION - Will be set by JavaScript */
#custom-start-expanded.dynamic-height {
    position: fixed; /* Fixed positioning for viewport calculation */
    max-height: none; /* Remove fixed max-height */
}

/* CUSTOM SCROLLBAR for starting panel */
#custom-start-expanded::-webkit-scrollbar {
    width: 6px !important; /* Different width than other scrollbars */
}

#custom-start-expanded::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.05) !important;
    border-radius: 3px !important; /* Different radius */
    margin: 4px 0 !important;
}

#custom-start-expanded::-webkit-scrollbar-thumb {
    background: rgba(59, 130, 246, 0.5) !important; /* Blue color */
    border-radius: 3px !important;
    border: 1px solid rgba(255,255,255,0.1) !important;
}

#custom-start-expanded::-webkit-scrollbar-thumb:hover {
    background: rgba(59, 130, 246, 0.7) !important;
}

/* Fix search results overflow */
#custom-start-search-results {
    max-height: 200px;
    overflow-y: auto;
    margin-top: 8px;
    display: none;
}

/* Different scrollbar for search results inside starting panel */
#custom-start-search-results::-webkit-scrollbar {
    width: 4px !important;
}

#custom-start-search-results::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.03) !important;
}

#custom-start-search-results::-webkit-scrollbar-thumb {
    background: rgba(139, 92, 246, 0.5) !important; /* Purple color */
}

/* Remove the duplicate styles and keep only this: */
#custom-start-panel {
    position: absolute;
    top: 180px; /* Below the Signal State panel (80px + height of panels + gap) */
    left: 24px;
    z-index: 1001; /* Higher than standard-ui (1000) */
    width: 340px;
    pointer-events: auto;
}

/* Make the expanded panel FIXED to viewport */
#custom-start-expanded {
    display: none;
    position: fixed; /* Changed from absolute to fixed */
    margin-top: 8px;
    padding: 16px;
    background: var(--glass-surface);
    backdrop-filter: blur(30px);
    border: 1px solid var(--glass-border);
    border-radius: 12px;
    box-shadow: 0 24px 60px rgba(0,0,0,0.9);
    overflow-y: auto;
    max-height: calc(100vh - 200px); /* Dynamic based on viewport */
    width: 340px; /* Same width as parent */
    z-index: 1002; /* Even higher */
}

    .leaflet-popup-content {
        font-family: 'Manrope', sans-serif !important;
        margin: 12px !important;
        min-width: fit-content !important;
    }
    
    .leaflet-popup-content-wrapper {
        background: var(--glass-surface) !important;
        backdrop-filter: blur(30px) !important;
        border: 1px solid var(--glass-border) !important;
        border-radius: 12px !important;
        box-shadow: 0 8px 32px rgba(0,0,0,0.9) !important;
    }
    
    .leaflet-popup-tip {
        background: var(--glass-surface) !important;
        border: 1px solid var(--glass-border) !important;
        box-shadow: 0 4px 16px rgba(0,0,0,0.9) !important;
    }
    
    .leaflet-popup-close-button {
        color: #9ca3af !important;
        font-size: 18px !important;
        padding: 4px 8px !important;
        transition: all 0.2s !important;
    }

.leaflet-container a.leaflet-popup-close-button {
    right: 5px !important;
}
    
    .leaflet-popup-close-button:hover {
        color: white !important;
        background: transparent !important;
    }

.leaflet-popup {
    min-width: 180px;
}
    </style>

<style>
    .starting-panel-container {
        position: relative;
        width: 100%;
    }

    #custom-start-panel {
        position: absolute;
        top: 160px; /* Fixed position below signal state */
        left: 24px;
        z-index: 999; /* Lower than search panel (1000) */
        width: 340px;
        pointer-events: auto;
        margin-top: 8px; /* Small gap from signal state */
    }

    body.navigating #custom-start-panel {
        display: none !important;
    }

    .destination-marker {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #ef4444;
        border: 3px solid white;
        box-shadow: 0 0 15px rgba(239, 68, 68, 0.7);
        position: relative;
    }
    
    .destination-marker::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 8px;
        height: 8px;
        background: white;
        border-radius: 50%;
    }

    #custom-start-expanded {
        display: none;
        position: absolute; /* Changed from fixed to absolute */
        margin-top: 8px;
        padding: 16px;
        background: var(--glass-surface);
        backdrop-filter: blur(30px);
        border: 1px solid var(--glass-border);
        border-radius: 12px;
        box-shadow: 0 24px 60px rgba(0,0,0,0.9);
        overflow-y: auto;
        width: 100%; /* Full width of parent */
        box-sizing: border-box;
        z-index: 1002;
max-height: 270px !important;
    }

    /* Set a reasonable maximum height that won't exceed viewport */
    #custom-start-expanded {
        max-height: 400px; /* Fixed max height */
    }

    /* Custom scrollbar for starting panel */
    #custom-start-expanded::-webkit-scrollbar {
        width: 6px !important;
    }

    #custom-start-expanded::-webkit-scrollbar-track {
        background: rgba(255,255,255,0.05) !important;
        border-radius: 3px !important;
        margin: 4px 0 !important;
    }

    #custom-start-expanded::-webkit-scrollbar-thumb {
        background: rgba(59, 130, 246, 0.5) !important;
        border-radius: 3px !important;
        border: 1px solid rgba(255,255,255,0.1) !important;
    }

    #custom-start-expanded::-webkit-scrollbar-thumb:hover {
        background: rgba(59, 130, 246, 0.7) !important;
    }

    /* Fix search results inside starting panel to have their own scroll */
    #custom-start-search-results {
        max-height: 150px; /* Smaller fixed height */
        overflow-y: auto;
        margin-top: 8px;
        display: none;
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 8px;
        background: rgba(0,0,0,0.3);
    }

    /* Different scrollbar for search results inside starting panel */
    #custom-start-search-results::-webkit-scrollbar {
        width: 4px !important;
    }

    #custom-start-search-results::-webkit-scrollbar-track {
        background: rgba(255,255,255,0.03) !important;
    }

    #custom-start-search-results::-webkit-scrollbar-thumb {
        background: rgba(139, 92, 246, 0.5) !important;
    }

@media (max-width: 775px) {
#info-sidebar {
width: 92% !important;
}
        body.navigating #info-sidebar {
            display: none !important;
        }
}

/* Click highlight animation */
.click-highlight {
    animation: highlightPulse 1.5s ease-out;
}

@keyframes highlightPulse {
    0% {
        transform: scale(0.5);
        opacity: 0.8;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.4;
    }
    100% {
        transform: scale(1.5);
        opacity: 0;
    }
}

/* Map click mode */
.map-click-mode-active {
    cursor: crosshair !important;
}

.map-click-mode-active .leaflet-interactive {
    cursor: crosshair !important;
}

/* Navigation arrows */
.nav-arrow {
    opacity: 0.7;
    transition: opacity 0.3s;
}

.nav-arrow:hover {
    opacity: 1;
}

/* Navigation markers */
.nav-start-marker {
    animation: pulseStart 2s infinite;
}

.nav-end-marker {
    animation: pulseEnd 2s infinite;
}

@keyframes pulseStart {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

@keyframes pulseEnd {
    0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
    100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
}

/* Navigation camera smoothing */
.leaflet-fade-anim .leaflet-tile,
.leaflet-zoom-anim .leaflet-zoom-animated {
    will-change: transform, opacity;
}

/* Better route line */
.leaflet-interactive {
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* Map mode button states */
.start-mode-btn.map-active {
    background: rgba(59, 130, 246, 0.3) !important;
    border-color: #3b82f6 !important;
    color: #93c5fd !important;
    animation: pulseMapMode 2s infinite;
}

@keyframes pulseMapMode {
    0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
    70% { box-shadow: 0 0 0 6px rgba(59, 130, 246, 0); }
    100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
}

/* Map in click mode */
.map-click-mode-active {
    cursor: crosshair !important;
}

.map-click-mode-active .leaflet-interactive {
    cursor: crosshair !important;
}

/* Click highlight */
.click-highlight {
    pointer-events: none;
    z-index: 1000;
}

/* Navigation user marker */
.nav-user-marker {
    animation: navUserPulse 2s infinite;
}

@keyframes navUserPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

/* Navigation arrows */
.nav-arrow-icon {
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
    opacity: 0.9;
    transition: opacity 0.3s;
}

.nav-arrow-icon:hover {
    opacity: 1;
    transform: scale(1.1);
}
</style>
</head>
<body class="bg-black">

    <div id="loader">
        <svg viewBox="0 0 76 65" fill="white" class="w-12 h-12 mb-4 animate-pulse"><path d="M37.5274 0L75.0548 65H0L37.5274 0Z"></path></svg>
        <div class="text-[9px] font-bold text-neutral-500 uppercase tracking-[0.5em]">Requesting Locaton...</div>
        <div class="loading-bar"><div class="loading-fill"></div></div>
    </div>

    <div id="map"></div>

    <div id="standard-ui" class="absolute top-6 left-6 z-[1000] w-[340px] flex flex-col gap-3">
        <div class="strike-glass p-2 ui-animate">
            <div class="relative group">
                <iconify-icon icon="lucide:search" class="absolute left-3 top-2.5 text-neutral-500"></iconify-icon>
                <input type="text" id="search-input" placeholder="Search destination..." class="w-full h-10 pl-10 pr-4 rounded-xl text-xs font-bold strike-input">
                <div id="search-spinner" class="hidden absolute right-3 top-3"><iconify-icon icon="lucide:loader-2" class="animate-spin text-white"></iconify-icon></div>
            </div>
            <div id="filters" class="hidden mt-2 flex gap-1 flex-wrap">
                <button class="filter-btn active" data-filter="all">All</button>
                <button class="filter-btn" data-filter="nearby">Near Me</button>
                <button class="filter-btn" data-filter="hotels">Hotels</button>
                <button class="filter-btn" data-filter="parks">Parks</button>
                <button class="filter-btn" data-filter="restaurants">Restaurants</button>
                <button class="filter-btn" data-filter="gas">Gas Stations</button>
            </div>
            <div id="results" class="hidden mt-2 flex flex-col"></div>
        </div>
        <div class="strike-glass px-4 py-3 flex items-center justify-between ui-animate">
            <div class="flex flex-col">
                <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-tight">Your Location</span>
                <span id="status-text" class="text-[11px] font-bold text-white">Standby</span>
            </div>
            <button id="locate-btn" class="h-8 px-4 bg-white text-black rounded-lg text-[11px] font-extrabold flex items-center gap-2 hover:bg-neutral-100 transition-all">
                <iconify-icon icon="lucide:crosshair"></iconify-icon> Re-Center
            </button>
        </div>

    </div>

<div id="custom-start-panel" class="strike-glass ui-animate">
    <div class="starting-panel-container">
        <button id="custom-start-toggle" class="w-full">
            <div class="flex justify-between items-center w-full">
                <span>Starting Point: <span id="current-start-mode">Current Location</span></span>
                <iconify-icon icon="lucide:chevron-down"></iconify-icon>
            </div>
        </button>
        <div id="custom-start-expanded">
            <div class="space-y-2">
                <button class="start-mode-btn active" data-mode="current">
                    <iconify-icon icon="lucide:crosshair"></iconify-icon>
                    Use Current Location
                </button>
                <button class="start-mode-btn" data-mode="map">
                    <iconify-icon icon="lucide:map-pin"></iconify-icon>
                    Click on Map
                </button>
                <button class="start-mode-btn" data-mode="search">
                    <iconify-icon icon="lucide:search"></iconify-icon>
                    Search for Location
                </button>
            </div>
            
            <div id="custom-start-input-container">
                <div class="relative mt-3">
                    <iconify-icon icon="lucide:search" class="absolute left-3 top-2.5 text-neutral-500"></iconify-icon>
                    <input type="text" id="custom-start-input" placeholder="Enter starting address or city..." class="w-full h-10 pl-10 pr-4 rounded-xl text-xs font-bold strike-input">
                </div>
                <div id="custom-start-search-results" class="flex flex-col"></div>
            </div>
            
            <div id="current-start-display" class="current-start-display mt-3">
                <div class="font-semibold text-white">Current start point:</div>
                <div class="text-[9px] mt-1" id="start-point-coords">Your current location</div>
            </div>
        </div>
    </div>
</div>

    <div id="active-nav-hud" class="absolute top-6 left-6 z-[2000] w-[340px] flex flex-col gap-3">
        <div class="strike-glass p-4">
            <div class="flex items-center gap-4">
                <div class="w-12 h-12 rounded-xl bg-white/10 flex items-center justify-center">
                    <iconify-icon id="nav-step-icon" icon="lucide:navigation" class="text-2xl text-emerald-400"></iconify-icon>
                </div>
                <div class="flex-1">
                    <span id="nav-dist-next" class="text-[10px] font-bold text-emerald-400 uppercase tracking-widest mb-1">In 200m</span>
                    <h3 id="nav-instruction" class="nav-instruction-text font-bold text-white leading-tight">Continue straight for 1.2 kilometers on Main Street</h3>
                    <div class="progress-bar">
                        <div id="step-progress" class="progress-fill" style="width: 30%"></div>
                    </div>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-white/5">
                <div class="flex justify-between text-[11px]">
                    <div>
                        <div class="text-neutral-500 mb-1">Next Turn</div>
                        <div id="nav-next-turn" class="text-white font-semibold">Right onto Broadway</div>
                    </div>
                    <div>
                        <div class="text-neutral-500 mb-1">ETA</div>
                        <div id="nav-eta" class="text-emerald-400 font-bold">14:30</div>
                    </div>
                    <div>
                        <div class="text-neutral-500 mb-1">Remaining</div>
                        <div id="nav-remaining" class="text-white font-bold">4.2 km</div>
                    </div>
                </div>
            </div>
        </div>
        <button id="exit-nav-btn" class="w-full h-10 bg-red-500/25 border border-red-500/50 text-white rounded-xl text-[10px] font-black uppercase tracking-widest flex items-center justify-center gap-2 hover:bg-red-500 transition-all duration-200">
            <iconify-icon icon="lucide:x-circle"></iconify-icon> Exit Navigation
        </button>
    </div>

    <div id="info-sidebar" class="strike-glass">
        <div class="p-6 border-b border-white/5 flex items-center justify-between">
            <h2 id="side-title" class="text-xl font-bold text-white truncate pr-4">Location</h2>
            <button onclick="closeSidebar()" class="text-neutral-500 hover:text-white"><iconify-icon icon="lucide:x" class="text-xl"></iconify-icon></button>
        </div>
        <div id="sidebar-content" class="p-6 flex-1 overflow-y-auto">
            <!-- Content will be dynamically populated -->
        </div>
        <div class="p-6 bg-white/[0.02] border-t border-white/5 flex gap-2">
            <button id="start-nav-btn" class="hidden flex-1 h-12 bg-white text-black rounded-xl text-xs font-black flex items-center justify-center gap-3">
                <iconify-icon icon="lucide:navigation-2" class="text-lg"></iconify-icon> START NAVIGATION
            </button>
        </div>
    </div>

    <div class="absolute bottom-6 right-6 z-[1000] flex flex-col gap-3 ui-animate">
        <div class="strike-glass p-1 flex flex-col gap-1">
            <button id="sat-toggle" class="w-10 h-10 flex items-center justify-center rounded-xl text-neutral-400 hover:text-white transition-all"><iconify-icon icon="lucide:layers" class="text-lg"></iconify-icon></button>
        </div>
        <div class="strike-glass p-1 flex flex-col gap-1">
            <button id="zoom-in" class="w-10 h-10 flex items-center justify-center rounded-xl hover:bg-white/10 text-neutral-400 hover:text-white transition-all"><iconify-icon icon="lucide:plus"></iconify-icon></button>
            <button id="zoom-out" class="w-10 h-10 flex items-center justify-center rounded-xl hover:bg-white/10 text-neutral-400 hover:text-white transition-all"><iconify-icon icon="lucide:minus"></iconify-icon></button>
        </div>
    </div>

    <div class="absolute bottom-6 left-6 z-[1000] pointer-events-none flex flex-col gap-4 ui-animate">
<div class="strike-glass px-4 py-3 flex gap-6 items-center pointer-events-auto">
    <div class="flex flex-col">
        <span id="hud-coords" class="nav-hud-pos text-[10px] font-mono text-white mt-1">0.0, 0.0</span>
        <span id="hud-eta" class="nav-hud-eta text-[10px] font-mono text-emerald-400 mt-1">--:--</span>
    </div>
    <div class="flex flex-col">
        <span id="hud-precision" class="nav-hud-acc text-[10px] font-mono text-white mt-1">-- m</span>
        <span id="hud-remaining" class="nav-hud-distance text-[10px] font-mono text-white mt-1">-- km</span>
    </div>
</div>
        <div class="opacity-40 text-[10px] font-black uppercase tracking-widest text-white flex items-center gap-2">
            <svg width="12" height="12" viewBox="0 0 76 65" fill="white"><path d="M37.5274 0L75.0548 65H0L37.5274 0Z"></path></svg>
            Strike Maps [V5]
        </div>
    </div>


    <script>
        // Initialize variables
        let map = null;
        let darkBase = null;
        let satLayer = null;
        const userIcon = L.divIcon({ 
            className: 'user-location-marker', 
            html: '<div class="gps-ring"></div>', 
            iconSize: [24, 24], 
            iconAnchor: [12, 12] 
        });
        let userMarker = L.marker([0,0], {icon: userIcon});
        let routeLayer = L.layerGroup();
        let userPos = null;
        let selectedTarget = null;
        let currentRoute = null;
        let currentNavRoute = null;
        let currentStepIndex = 0;
        let searchResults = [];
        let activeFilter = 'all';
        let isNavigating = false;
        let recentSearches = [];

        try {
            const storedSearches = localStorage.getItem('strikeRecentSearches');
            if (storedSearches) {
                recentSearches = JSON.parse(storedSearches);
                if (!Array.isArray(recentSearches)) {
                    recentSearches = [];
                    localStorage.removeItem('strikeRecentSearches');
                }
            }
        } catch (error) {
            console.error("Error loading recent searches:", error);
            recentSearches = [];
            localStorage.removeItem('strikeRecentSearches');
        }
        
        let watchId = null;
        let totalRouteDistance = 0;
        let remainingDistance = 0;
        let gpsWatchInterval = null;
        let isLocationRequested = false;
        let routeStartTime = null;
        
        // NEW VARIABLES FOR CUSTOM START POINT
        let customStartMode = 'current'; // 'current', 'map', 'search'
        let customStartPos = null;
        let customStartMarker = null;
        let destinationMarker = null;
        
        // ============== MISSING FUNCTION DEFINITIONS ==============

        // 1. Create straight path (for ferry/fallback routes)
        function createStraightPath(start, end) {
            return {
                type: "LineString",
                coordinates: [
                    [start[1], start[0]],
                    [end[1], end[0]]
                ]
            };
        }

        // 2. Real weather data using Open-Meteo (FREE, no API key)
        async function getRealWeatherAtLocation(lat, lng) {
            try {
                const response = await fetch(
                    `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current=temperature_2m,wind_speed_10m,precipitation,weather_code&timezone=auto`
                );
                const data = await response.json();
                
                if (data.current) {
                    const weatherCode = data.current.weather_code;
                    let conditions = "Clear";
                    if (weatherCode > 0 && weatherCode < 50) conditions = "Cloudy";
                    if (weatherCode >= 50 && weatherCode < 70) conditions = "Rainy";
                    if (weatherCode >= 70) conditions = "Snowy";
                    
                    return {
                        temperature: data.current.temperature_2m,
                        windSpeed: data.current.wind_speed_10m,
                        precipitation: data.current.precipitation,
                        conditions: conditions,
                        weatherCode: weatherCode
                    };
                }
            } catch (error) {
                console.error("Weather API failed:", error);
            }
            return null;
        }

        // 3. Real traffic estimation using OpenStreetMap data (FREE)
        async function getRealTrafficEstimate(start, end) {
            try {
                // Get route from OSRM with traffic consideration
                const response = await fetch(
                    `https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=false&alternatives=false&steps=true`
                );
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    const now = new Date();
                    const hour = now.getHours();
                    const isRushHour = (hour >= 7 && hour <= 9) || (hour >= 16 && hour <= 18);
                    const isWeekend = now.getDay() === 0 || now.getDay() === 6;
                    
                    // Analyze route complexity
                    const steps = route.legs?.[0]?.steps || [];
                    const intersections = steps.filter(step => 
                        step.maneuver?.type.includes('turn') || 
                        step.maneuver?.type.includes('roundabout')
                    ).length;
                    
                    // Realistic traffic estimation
                    let trafficFactor = 1.0;
                    if (isRushHour && !isWeekend) trafficFactor *= 1.4;
                    if (intersections > 10) trafficFactor *= 1.2;
                    
                    // Weather impact
                    const weather = await getRealWeatherAtLocation(start[0], start[1]);
                    if (weather?.conditions === "Rainy") trafficFactor *= 1.3;
                    if (weather?.conditions === "Snowy") trafficFactor *= 1.6;
                    
                    return {
                        duration: route.duration * trafficFactor,
                        trafficLevel: trafficFactor > 1.4 ? 'high' : trafficFactor > 1.2 ? 'medium' : 'low',
                        intersections: intersections,
                        weatherImpact: weather?.conditions || "Clear"
                    };
                }
            } catch (error) {
                console.error("Traffic estimation failed:", error);
            }
            
            // Fallback
            return {
                duration: null,
                trafficLevel: 'medium',
                intersections: 0,
                weatherImpact: "Unknown"
            };
        }

        // 4. Real airport data from OurAirports (FREE database)
async function getAllAirports() {
    try {
        // Use a better data source with proper airport types
        const response = await fetch('https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat');
        const data = await response.text();
        
        const airports = [];
        const lines = data.split('\n');
        
        for (const line of lines) {
            if (!line.trim()) continue;
            
            const fields = line.split(',');
            if (fields.length >= 14) {
                const name = fields[1].replace(/"/g, '');
                const city = fields[2].replace(/"/g, '');
                const country = fields[3].replace(/"/g, '');
                const iata = fields[4].replace(/"/g, '');
                const icao = fields[5].replace(/"/g, '');
                const lat = parseFloat(fields[6]);
                const lng = parseFloat(fields[7]);
                
                // CRITICAL: Only include airports with IATA codes AND are major
                if (iata && iata.length === 3 && 
                    !isNaN(lat) && !isNaN(lng) &&
                    // EXCLUDE small/specialized airports
                    !name.toLowerCase().includes('seaplane') &&
                    !name.toLowerCase().includes('heliport') &&
                    !name.toLowerCase().includes('airfield') &&
                    !name.toLowerCase().includes('municipal') &&
                    !name.toLowerCase().includes('regional') &&
                    !name.toLowerCase().includes('executive') &&

                    // INCLUDE only commercial airports
                    (name.toLowerCase().includes('international') || 
                     icao.length === 4)) { // ICAO codes indicate real airports
                    
                    airports.push({
                        code: iata,
                        name: name,
                        city: city,
                        country: country,
                        coordinates: [lat, lng],
                        type: name.includes('International') ? 'large' : 'medium'
                    });
                }
            }
        }
        
        return airports;
        
    } catch (error) {
        console.error("Airport data failed:", error);
        return getCommercialAirports(); // Fallback
    }
}

        // 5. Real ferry data from OpenStreetMap (FREE)
        async function getFerryRoutes(start, end) {
            try {
                const [startLng, startLat] = [start[1], start[0]];
                const [endLng, endLat] = [end[1], end[0]];
                
                // Query OpenStreetMap for ferry routes (Overpass API - FREE)
                const bbox = [
                    Math.min(startLat, endLat) - 0.5,
                    Math.min(startLng, endLng) - 0.5,
                    Math.max(startLat, endLat) + 0.5,
                    Math.max(startLng, endLng) + 0.5
                ].join(',');
                
                const query = `
                    [out:json][timeout:10];
                    (
                        way["route"="ferry"](${bbox});
                        relation["route"="ferry"](${bbox});
                        node["amenity"="ferry_terminal"](${bbox});
                    );
                    out body;
                `;
                
                const response = await fetch(
                    `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`
                );
                const data = await response.json();
                
                if (data.elements && data.elements.length > 0) {
                    const ferryTerminals = data.elements.filter(el => 
                        el.type === 'node' && el.tags?.amenity === 'ferry_terminal'
                    );
                    
                    // Check if start/end are near ferry terminals
                    const startTerminal = findNearestTerminal(start, ferryTerminals);
                    const endTerminal = findNearestTerminal(end, ferryTerminals);
                    
                    if (startTerminal && endTerminal) {
                        const distance = map.distance(start, end);
                        // Average ferry speed: 40 km/h (11.1 m/s)
                        const ferryTime = (distance / 11100) * 3600; // Convert to hours
                        
                        return {
                            hasFerry: true,
                            duration: ferryTime + 1800, // +30 min for boarding
                            distance: distance,
                            terminals: {
                                start: startTerminal.name,
                                end: endTerminal.name
                            },
                            details: `Ferry from ${startTerminal.name} to ${endTerminal.name}`
                        };
                    }
                }
            } catch (error) {
                console.error("Ferry route check failed:", error);
            }
            
            return { hasFerry: false };
        }

        function findNearestTerminal(point, terminals) {
            const [lat, lng] = point;
            let nearest = null;
            let minDistance = Infinity;
            
            for (const terminal of terminals) {
                if (terminal.lat && terminal.lon) {
                    const distance = map.distance([lat, lng], [terminal.lat, terminal.lon]);
                    if (distance < 50000 && distance < minDistance) { // Within 50km
                        minDistance = distance;
                        nearest = {
                            name: terminal.tags?.name || "Ferry Terminal",
                            lat: terminal.lat,
                            lng: terminal.lon,
                            distance: distance
                        };
                    }
                }
            }
            
            return nearest;
        }

        // 6. Real cycling/walking times with elevation consideration
        async function getElevationAdjustedTime(start, end, mode) {
            try {
                // Get elevation data from Open-Elevation (FREE)
                const response = await fetch(
                    `https://api.open-elevation.com/api/v1/lookup?locations=${start[0]},${start[1]}|${end[0]},${end[1]}`
                );
                const data = await response.json();
                
                if (data.results && data.results.length === 2) {
                    const startElev = data.results[0].elevation;
                    const endElev = data.results[1].elevation;
                    const elevationGain = Math.max(0, endElev - startElev);
                    
                    // Base speeds
                    let baseSpeed = mode === 'cycling' ? 15000 : 5000; // m/h
                    
                    // Adjust for elevation
                    if (elevationGain > 100) {
                        baseSpeed *= 0.7; // 30% slower for significant climbs
                    } else if (elevationGain < -100) {
                        baseSpeed *= 1.3; // 30% faster for descents
                    }
                    
                    const distance = map.distance(start, end);
                    return (distance / baseSpeed) * 3600; // Convert to seconds
                }
            } catch (error) {
                console.error("Elevation API failed:", error);
            }
            
            // Fallback: straight distance calculation
            const distance = map.distance(start, end);
            const baseSpeed = mode === 'cycling' ? 15000 : 5000;
            return (distance / baseSpeed) * 3600;
        }

        // 7. Missing helper functions
        function getFallbackAirports() {
            return getCommercialAirports();
        }

        function cityPopulationLookup(city, country) {
            // Simplified population estimation
            const majorCities = {
                "New York": 8419000,
                "Los Angeles": 3980000,
                "Chicago": 2716000,
                "Houston": 2328000,
                "Phoenix": 1689000,
                "Philadelphia": 1584000,
                "San Antonio": 1547000,
                "San Diego": 1426000,
                "Dallas": 1344000,
                "San Jose": 1035000,
                "London": 8900000,
                "Paris": 2148000,
                "Berlin": 3769000,
                "Madrid": 3223000,
                "Rome": 2873000,
                "Tokyo": 13960000,
                "Beijing": 21540000,
                "Shanghai": 26320000,
                "Delhi": 32941000,
                "Mumbai": 21357000
            };
            
            return majorCities[city] || 100000; // Default to 100k if unknown
        }

        function isMajorCity(city, country) {
            const majorCities = [
                "New York", "Los Angeles", "Chicago", "Houston", "Phoenix",
                "Philadelphia", "San Antonio", "San Diego", "Dallas", "San Jose",
                "London", "Paris", "Berlin", "Madrid", "Rome", "Barcelona",
                "Tokyo", "Beijing", "Shanghai", "Delhi", "Mumbai", "Sydney",
                "Melbourne", "Toronto", "Vancouver", "Montreal", "Mexico City",
                "SÃ£o Paulo", "Rio de Janeiro", "Buenos Aires", "Cairo", "Johannesburg"
            ];
            
            return majorCities.includes(city);
        }

        async function getFlightStatus(departureAirport, arrivalAirport) {
    // OpenSky API doesn't allow future/historical without auth
    // Return estimated flight time instead
    const flightDistance = map.distance(departureAirport.coordinates, arrivalAirport.coordinates);
    const flightTime = (flightDistance / 750000) * 3600; // 750 km/h average
    
    return {
        available: true,
        duration: flightTime,
        airline: "Estimated",
        status: "Estimated"
    };
}

        // 9. Enhanced calculateRoutes with real data
        async function calculateRealRoutes(start, end) {
            const routes = [];
            const directDistance = map.distance(start, end);
            
            // Get real-time data in parallel
            const [trafficData, weatherData, ferryData] = await Promise.all([
                getRealTrafficEstimate(start, end),
                getRealWeatherAtLocation(start[0], start[1]),
                getFerryRoutes(start, end)
            ]);
            
            // DRIVING - with real traffic
            try {
                const drivingResponse = await fetch(
                    `https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson&steps=true`
                );
                const drivingData = await drivingResponse.json();
                
                if (drivingData.routes?.[0]) {
                    const baseDuration = drivingData.routes[0].duration;
                    const adjustedDuration = trafficData.duration || baseDuration * 1.2;
                    
                    routes.push({
                        id: 'driving',
                        icon: 'lucide:car',
                        label: 'Driving',
                        duration: adjustedDuration,
                        distance: drivingData.routes[0].distance,
                        geometry: drivingData.routes[0].geometry,
                        steps: processOSRMSteps(drivingData.routes[0].legs?.[0]?.steps || []),
                        traffic: trafficData.trafficLevel,
                        weather: weatherData?.conditions,
                        realData: true
                    });
                }
            } catch (error) {
                console.error("Driving route failed:", error);
            }
            
            // CYCLING - with elevation adjustment
            try {
                const cyclingTime = await getElevationAdjustedTime(start, end, 'cycling');
                
                routes.push({
                    id: 'cycling',
                    icon: 'lucide:bike',
                    label: 'Cycling',
                    duration: cyclingTime,
                    distance: directDistance,
                    geometry: createStraightPath(start, end),
                    steps: [],
                    elevationAdjusted: true,
                    realData: true
                });
            } catch (error) {
                console.error("Cycling route failed:", error);
            }
            
            // WALKING - with elevation adjustment
            try {
                const walkingTime = await getElevationAdjustedTime(start, end, 'walking');
                
                routes.push({
                    id: 'walking',
                    icon: 'lucide:footprints',
                    label: 'Walking',
                    duration: walkingTime,
                    distance: directDistance,
                    geometry: createStraightPath(start, end),
                    steps: [],
                    elevationAdjusted: true,
                    realData: true
                });
            } catch (error) {
                console.error("Walking route failed:", error);
            }
            
            // FERRY - if available
            if (ferryData.hasFerry && directDistance > 10000 && directDistance < 500000) {
                routes.push({
                    id: 'ferry',
                    icon: 'lucide:ship',
                    label: 'Ferry',
                    duration: ferryData.duration,
                    distance: ferryData.distance,
                    geometry: createStraightPath(start, end),
                    steps: [{
                        distance: ferryData.distance,
                        duration: ferryData.duration,
                        maneuver: {
                            instruction: `Take ferry from ${ferryData.terminals.start} to ${ferryData.terminals.end}`,
                            type: 'ferry'
                        }
                    }],
                    realData: true
                });
            }
            
            // FLIGHT - only for long distances
            if (directDistance > 300000) {
                const flightRoute = await calculateSmartFlightRoute(start, end, directDistance);
                if (flightRoute) {
                    routes.push(flightRoute);
                }
            }
            
            return routes;
        }

        // 10. Smart flight route with real data
        async function calculateSmartFlightRoute(start, end, distance) {
            try {
                // Load airports
                const airports = await getAllAirports();
                
                // Sort by airport size AND distance
       const startAirports = airports
            .map(airport => ({
                ...airport,
                distance: map.distance(start, airport.coordinates),
                score: calculateAirportScore(airport, start) // USE SCORING FUNCTION
            }))
            .filter(a => a.distance < 150000) // Within 150km
            .sort((a, b) => b.score - a.score); // Higher score first
                
                const endAirports = airports
                    .map(a => ({
                        ...a,
                        distance: map.distance(end, a.coordinates)
                    }))
                    .filter(a => a.distance < 150000)
                    .sort((a, b) => a.distance - b.distance);
                
                if (startAirports.length === 0 || endAirports.length === 0) return null;
                
                const startAirport = startAirports[0];
                const endAirport = endAirports[0];
                
                if (startAirport.code === endAirport.code) return null;
                
                const airportDistance = map.distance(startAirport.coordinates, endAirport.coordinates);
                if (airportDistance < 500000) return null;
                
                const flightData = await getFlightStatus(startAirport, endAirport);
                
                // Calculate times
                const groundSpeed = 50000; // 50 km/h for ground transport
                const toAirportTime = (startAirport.distance / groundSpeed) * 3600;
                const fromAirportTime = (endAirport.distance / groundSpeed) * 3600;
                
                // Use real flight duration if available, otherwise estimate
                const flightTime = flightData.duration || (airportDistance / 750000) * 3600;
                const airportTime = 7200; // 2 hours for airport processes
                
                const totalTime = toAirportTime + flightTime + fromAirportTime + airportTime;
                
                // Only suggest if it makes sense
                const drivingEstimate = (distance / 80000) * 3600;
                if (totalTime > drivingEstimate * 0.8) return null;
                
                return {
                    id: 'flight',
                    icon: 'lucide:plane',
                    label: 'Flight',
                    duration: totalTime,
                    distance: airportDistance,
                    geometry: createFlightPath(startAirport.coordinates, endAirport.coordinates),
                    steps: [
                        {
                            distance: startAirport.distance,
                            duration: toAirportTime,
                            maneuver: { instruction: `Travel to ${startAirport.name}`, type: 'ground' }
                        },
                        {
                            distance: airportDistance,
                            duration: flightTime,
                            maneuver: { instruction: `Fly to ${endAirport.name}`, type: 'flight' }
                        },
                        {
                            distance: endAirport.distance,
                            duration: fromAirportTime,
                            maneuver: { instruction: `Travel to destination`, type: 'ground' }
                        }
                    ],
                    airports: { departure: startAirport, arrival: endAirport },
                    flightData: flightData,
                    realData: true,
                    details: `${startAirport.code} â ${endAirport.code}`
                };
                
            } catch (error) {
                console.error("Smart flight route failed:", error);
                return null;
            }
        }

        // 11. Update the main calculateRoutes function to use real data
        async function calculateRoutes(start, end) {
            const container = document.getElementById('route-options');
            container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">Calculating real-time routes...</div>';
            
            try {
                // Use the new real data function
                const routes = await calculateRealRoutes(start, end);
                
                container.innerHTML = '';
                if (routes.length === 0) {
                    container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">No routes available</div>';
                    return;
                }
                
                routes.forEach(route => {
                    addRouteCard(route);
                });
                
            } catch (error) {
                console.error("Route calculation failed:", error);
                container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">Failed to calculate routes</div>';
            }
        }

        // ============== END OF MISSING FUNCTION DEFINITIONS ==============
        
        // Map initialization function
        function initMap() {
            map = L.map('map', { 
                zoomControl: false, 
                attributionControl: false, 
                maxBounds: [[-85, -10000], [85, 10000]], 
                maxBoundsViscosity: 1.0, 
                worldCopyJump: true, 
                minZoom: 3 
            }).setView([40.7128, -74.0060], 2); // Default to NYC
            
            darkBase = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                maxZoom: 19, 
                className: 'dark-layer' 
            }).addTo(map);
            
            satLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { 
                maxZoom: 19 
            });
            
            routeLayer.addTo(map);
            
            // Add user marker
            userMarker.addTo(map);
            
            // Initialize custom start marker
            customStartMarker = L.marker([0,0], {
                icon: L.divIcon({
                    className: 'custom-start-marker',
                    html: '<div style="background: #f59e0b; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(245,158,11,0.5);"></div>',
                    iconSize: [22, 22],
                    iconAnchor: [11, 11]
                })
            });

            destinationMarker = L.marker([0,0], {
                icon: L.divIcon({
                    className: 'destination-marker',
                    html: '<div style="background: #ef4444; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(239,68,68,0.5); position: relative;"><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 6px; height: 6px; background: white; border-radius: 50%;"></div></div>',
                    iconSize: [22, 22],
                    iconAnchor: [11, 11]
                }),
                zIndexOffset: 1000
            });
        }
        
        // Setup map event listeners
        function setupMapEvents() {
            if (!map) return;

            map.off('click');
            
            map.on('click', (e) => {
                if (isNavigating) return;
                
                if (isMapClickModeActive) {
                    return;
                } else {
                    // Normal behavior - trigger analysis on clicked point
                    triggerAnalysis(e.latlng.lat, e.latlng.lng);
                    hideSearchResults();
                }
            });
            
            map.on('mousemove', (e) => {
                document.getElementById('hud-coords').innerText = 
                    `${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`;
            });
            
            map.on('move', () => {
                hideSearchResults();
            });
        }
        
        // --- CUSTOM START POINT FUNCTIONS ---
        function toggleStartPanel(e) {
            e.stopPropagation();
            const expanded = document.getElementById('custom-start-expanded');
            const searchResults = document.getElementById('results');
            const customSearchResults = document.getElementById('custom-start-search-results');
            
            // Close search results if open
            if (searchResults && !searchResults.classList.contains('hidden')) {
                hideSearchResults();
            }
            
            // Close custom search results
            if (customSearchResults && customSearchResults.style.display === 'block') {
                customSearchResults.style.display = 'none';
            }
            
            // Toggle starting panel
            if (expanded.style.display === 'block') {
                expanded.style.display = 'none';
            } else {
                expanded.style.display = 'block';
                
                // Reset to default height (show full content)
                expanded.style.maxHeight = '400px';
                
                // Ensure the panel is visible in viewport
                const panelRect = expanded.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                
                // If panel would go below viewport, adjust max-height
                if (panelRect.bottom > viewportHeight - 10) {
                    const availableHeight = viewportHeight - panelRect.top - 20;
                    expanded.style.maxHeight = Math.max(150, availableHeight) + 'px';
                }
            }
        }

        window.addEventListener('resize', () => {
            const expanded = document.getElementById('custom-start-expanded');
            if (expanded.style.display === 'block') {
                const panelRect = expanded.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                
                // If panel goes below viewport, adjust max-height
                if (panelRect.bottom > viewportHeight - 10) {
                    const availableHeight = viewportHeight - panelRect.top - 20;
                    expanded.style.maxHeight = Math.max(150, availableHeight) + 'px';
                } else {
                    expanded.style.maxHeight = '400px';
                }
            }
        });

        // Update click outside detection
        document.addEventListener('click', (e) => {
            const startPanel = document.getElementById('custom-start-panel');
            const startToggle = document.getElementById('custom-start-toggle');
            const startExpanded = document.getElementById('custom-start-expanded');
            const customStartInput = document.getElementById('custom-start-input');
            const customSearchResults = document.getElementById('custom-start-search-results');
            
            // Check if click is inside search results
            const isInSearchResults = customSearchResults && customSearchResults.contains(e.target);
            
            // Close starting point panel if clicking outside
            if (startExpanded.style.display === 'block' && 
                !startPanel.contains(e.target) && 
                e.target !== startToggle &&
                e.target !== customStartInput &&
                !isInSearchResults) {
                startExpanded.style.display = 'none';
            }
        });

        function calculateDynamicHeight() {
            const expanded = document.getElementById('custom-start-expanded');
            if (!expanded || expanded.style.display !== 'block') return;
            
            // Get viewport height
            const viewportHeight = window.innerHeight;
            
            // Get panel position and dimensions
            const panelRect = expanded.getBoundingClientRect();
            const toggleRect = document.getElementById('custom-start-toggle').getBoundingClientRect();
            
            // Calculate available space from panel top to 10px above bottom
            const spaceFromTop = toggleRect.top + toggleRect.height + 8; // Panel top position
            const spaceToBottom = viewportHeight - spaceFromTop - 10; // 10px margin from bottom
            
            // Set max height (but not less than 150px)
            const maxHeight = Math.max(150, Math.min(400, spaceToBottom));
            
            expanded.style.maxHeight = `${maxHeight}px`;
            expanded.style.position = 'absolute';
            expanded.style.top = 'calc(100% + 8px)';
            expanded.style.left = '0';
            expanded.style.right = '0';
        }

        // Recalculate height on window resize
        window.addEventListener('resize', calculateDynamicHeight);

        // Also recalculate when switching modes
        document.querySelectorAll('.start-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setTimeout(() => calculateDynamicHeight(), 100);
            });
        });

        // Recalculate when search results appear
        const customStartInput = document.getElementById('custom-start-input');
        customStartInput.addEventListener('input', () => {
            setTimeout(() => calculateDynamicHeight(), 200);
        });
        
        let isMapClickModeActive = false;
        let mapClickListener = null;

        function setStartMode(mode) {
            const previousMode = customStartMode;
            customStartMode = mode;
            
            // Remove any existing map click listener
            if (mapClickListener) {
                map.off('click', mapClickListener);
                mapClickListener = null;
            }
            
            // Reset map click mode flag based on mode
            isMapClickModeActive = (mode === 'map');
            
            // Update UI
            document.querySelectorAll('.start-mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                }
            });
            
            document.getElementById('current-start-mode').textContent = 
                mode === 'current' ? 'Current Location' :
                mode === 'map' ? 'Click on Map' :
                'Search for Location';
            
            // Handle map mode
            if (mode === 'map') {
                // Only enable clicking if we have a marker or this is first time
                if (!customStartPos || previousMode !== 'map') {
                    enableMapClickMode();
                } else {
                    // If we already have a marker, show active state but don't enable clicking
                    updateMapModeUI(true);
                }
                
                // Ensure map cursor is correct
                map.getContainer().style.cursor = isMapClickModeActive ? 'crosshair' : '';
                
            } else {
                disableMapClickMode();
            }
            
            // Show/hide search input
            const searchContainer = document.getElementById('custom-start-input-container');
            const searchResults = document.getElementById('custom-start-search-results');
            
            if (mode === 'search') {
                searchContainer.style.display = 'block';
                searchResults.style.display = 'none';
            } else {
                searchContainer.style.display = 'none';
                searchResults.style.display = 'none';
                document.getElementById('custom-start-input').value = '';
            }
            
            // Update marker
            updateCustomStartMarker();
            
            // Update display
            updateStartPointDisplay();
            
            // If we have a target selected, recalculate routes
            if (selectedTarget) {
                calculateRoutes(getCurrentStartPoint(), selectedTarget);
            }
        }

        function enableMapClickMode() {
            isMapClickModeActive = true;
            
            // Change cursor
            map.getContainer().style.cursor = 'crosshair';
            map.getContainer().classList.add('map-click-mode-active');
            
            // Update UI to show active state
            updateMapModeUI(true);
            
            // One-time click handler
            mapClickListener = (e) => {
                // Set the point
                setCustomStartFromMap(e.latlng);
                
                // DISABLE further map clicks
                disableMapClickMode();
                
                // But KEEP the mode as "map" in the UI
                // Don't call setStartMode('current')
            };
            
            map.on('click', mapClickListener);
        }

        function disableMapClickMode() {
            isMapClickModeActive = false;
            map.getContainer().style.cursor = '';
            map.getContainer().classList.remove('map-click-mode-active');
            
            // Update UI to show inactive state
            updateMapModeUI(false);
            
            if (mapClickListener) {
                map.off('click', mapClickListener);
                mapClickListener = null;
            }
        }

        function updateMapModeUI(isActive) {
            const mapModeBtn = document.querySelector('.start-mode-btn[data-mode="map"]');
            if (!mapModeBtn) return;
            
            if (isActive) {
                // Active state: blue background, white text
                mapModeBtn.style.background = 'rgba(59, 130, 246, 0.3)';
                mapModeBtn.style.borderColor = '#3b82f6';
                mapModeBtn.style.color = '#93c5fd';
                mapModeBtn.innerHTML = `
                    <iconify-icon icon="lucide:map-pin"></iconify-icon>
                    Click on Map <span style="font-size: 9px; opacity: 0.8;">(click map)</span>
                `;
            } else {
                // Inactive state: normal styling
                mapModeBtn.style.background = '';
                mapModeBtn.style.borderColor = '';
                mapModeBtn.style.color = '';
                mapModeBtn.innerHTML = `
                    <iconify-icon icon="lucide:map-pin"></iconify-icon>
                    Click on Map
                `;
            }
        }

        function showClickHighlight(latlng) {
            // Remove existing highlight
            removeClickHighlight();
            
            // Create a subtle pulse effect
            window.clickHighlight = L.circleMarker(latlng, {
                radius: 15,
                color: '#3b82f6',
                weight: 3,
                opacity: 0.8,
                fillColor: '#3b82f6',
                fillOpacity: 0.2,
                className: 'click-highlight'
            }).addTo(map);
            
            // Remove after 1.5 seconds
            setTimeout(() => {
                removeClickHighlight();
            }, 1500);
        }

        function removeClickHighlight() {
            if (window.clickHighlight) {
                map.removeLayer(window.clickHighlight);
                window.clickHighlight = null;
            }
        }
        
        function setCustomStartFromMap(latlng) {
            customStartPos = [latlng.lat, latlng.lng];
            
            // IMPORTANT: Keep mode as 'map' but disable active clicking
            // DON'T change the mode back to 'current'
            customStartMode = 'map';
            
            // Update marker
            updateCustomStartMarker();
            
            // Show temporary highlight
            showClickHighlight(latlng);
            
            // Reverse geocode to get address
            fetch(`https://photon.komoot.io/reverse?lon=${latlng.lng}&lat=${latlng.lat}&limit=1`)
                .then(res => res.json())
                .then(data => {
                    if (data.features && data.features.length > 0) {
                        const p = data.features[0].properties || {};
                        const address = [p.street, p.city, p.country].filter(Boolean).join(', ') || 
                                       `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
                        document.getElementById('start-point-coords').textContent = address;
                    } else {
                        document.getElementById('start-point-coords').textContent = 
                            `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
                    }
                })
                .catch(() => {
                    document.getElementById('start-point-coords').textContent = 
                        `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
                });
            
            // If we have a target selected, recalculate routes
            if (selectedTarget) {
                calculateRoutes(customStartPos, selectedTarget);
            }
            
            // Re-center map on clicked point
            map.flyTo(latlng, 15, {
                animate: true,
                duration: 0.5
            });
            
            // DO NOT change mode automatically
            // User remains in "map" mode but clicking is disabled until they click button again
        }
        
        function searchCustomStartLocation(query) {
            if (!query || query.trim().length < 2) {
                const container = document.getElementById('custom-start-search-results');
                container.style.display = 'none';
                return;
            }
            
            fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=10`)
                .then(res => res.json())
                .then(data => {
                    const results = data.features || [];
                    const container = document.getElementById('custom-start-search-results');
                    
                    if (results.length === 0) {
                        container.innerHTML = '<div class="text-xs text-neutral-500 p-2 text-center">No results found</div>';
                        container.style.display = 'block';
                        return;
                    }
                    
                    let html = '';
                    results.forEach(result => {
                        const props = result.properties;
                        const name = props.name || props.street || props.city || "Unnamed Location";
                        const details = [props.housenumber, props.street, props.city, props.country]
                            .filter(Boolean)
                            .join(', ') || 'Coordinates';
                        
                        html += `
                            <div class="search-result" data-lat="${result.geometry.coordinates[1]}" data-lng="${result.geometry.coordinates[0]}" data-name="${name}">
                                <div class="text-[11px] font-bold text-white mb-1">${name}</div>
                                <div class="text-[9px] text-neutral-400">${details}</div>
                            </div>
                        `;
                    });
                    
                    container.innerHTML = html;
                    container.style.display = 'block';
                    
                    // Ensure container doesn't exceed available space
                    const expanded = document.getElementById('custom-start-expanded');
                    const expandedRect = expanded.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    
                    // Calculate available space for search results
                    const resultsHeight = Math.min(150, viewportHeight - expandedRect.top - 180);
                    container.style.maxHeight = resultsHeight + 'px';
                    
                    // Add click handlers
                    document.querySelectorAll('#custom-start-search-results .search-result').forEach(item => {
                        item.addEventListener('click', () => {
                            const lat = parseFloat(item.dataset.lat);
                            const lng = parseFloat(item.dataset.lng);
                            const name = item.dataset.name;
                            
                            customStartPos = [lat, lng];
                            customStartMode = 'search';
                            updateCustomStartMarker();
                            
                            // Update display
                            document.getElementById('start-point-coords').textContent = name;
                            
                            // Hide results and clear input
                            container.style.display = 'none';
                            document.getElementById('custom-start-input').value = name;
                            
                            // If we have a target selected, recalculate routes
                            if (selectedTarget) {
                                calculateRoutes(customStartPos, selectedTarget);
                            }
                            
                            // Center map on selected location
                            map.flyTo([lat, lng], 14, { animate: true, duration: 1 });
                        });
                    });
                })
                .catch(error => {
                    console.error("Custom start search failed:", error);
                });
        }
        
        function updateCustomStartMarker() {
            // Remove existing marker
            if (map.hasLayer(customStartMarker)) {
                map.removeLayer(customStartMarker);
            }
            
            // Add marker if we have a custom position and mode is not 'current'
            if (customStartMode !== 'current' && customStartPos) {
                customStartMarker.setLatLng(customStartPos);
                customStartMarker.addTo(map);
            }
        }
        
        function updateStartPointDisplay() {
            let displayText = '';
            
            if (customStartMode === 'current') {
                displayText = 'Your current location';
            } else if (customStartMode === 'map' && customStartPos) {
                displayText = `${customStartPos[0].toFixed(4)}, ${customStartPos[1].toFixed(4)}`;
            } else if (customStartMode === 'search' && customStartPos) {
                displayText = document.getElementById('start-point-coords').textContent;
            } else {
                displayText = 'Your current location';
            }
            
            document.getElementById('start-point-coords').textContent = displayText;
        }
        
        function getCurrentStartPoint() {
            if (customStartMode === 'current') {
                return userPos || [40.7128, -74.0060]; // Fallback to NYC
            } else if (customStartPos) {
                return customStartPos;
            } else {
                return userPos || [40.7128, -74.0060];
            }
        }
        
        // --- LOAD & GPS ---
        window.onload = () => {
            initMap();
            
            // Setup custom start point UI
            document.getElementById('custom-start-toggle').addEventListener('click', toggleStartPanel);
            
            // Update the start mode button handler
            document.querySelectorAll('.start-mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    
                    // If clicking "Click on Map" button
                    if (mode === 'map') {
                        // If we're already in map mode but NOT in active click state
                        if (customStartMode === 'map' && !isMapClickModeActive) {
                            // Re-enable map clicking
                            enableMapClickMode();
                            return;
                        }
                        
                        // If we're already in map mode AND in active click state
                        if (customStartMode === 'map' && isMapClickModeActive) {
                            // Toggle off - switch to current location mode
                            setStartMode('current');
                            disableMapClickMode();
                            return;
                        }
                        
                        // Otherwise, switch to map mode
                        setStartMode('map');
                        
                    } else {
                        // For other modes (current, search)
                        setStartMode(mode);
                        disableMapClickMode();
                    }
                });
            });
            
            // Custom start search input
            const customStartInput = document.getElementById('custom-start-input');
            let customSearchTimeout;
            customStartInput.addEventListener('input', (e) => {
                clearTimeout(customSearchTimeout);
                customSearchTimeout = setTimeout(() => {
                    searchCustomStartLocation(e.target.value);
                }, 500);
            });
            
            customStartInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchCustomStartLocation(e.target.value);
                }
            });
            
            // After the setTimeout in window.onload:
            setTimeout(() => {
                if (navigator.geolocation && !isLocationRequested) {
                    isLocationRequested = true;
                    document.getElementById('status-text').innerText = "Acquiring Signal";
                    
                    navigator.geolocation.getCurrentPosition(
                        (pos) => {
                            userPos = [pos.coords.latitude, pos.coords.longitude];
                            userMarker.setLatLng(userPos);
                            map.setView(userPos, 14);
                            
                            document.getElementById('hud-precision').innerText = `${pos.coords.accuracy.toFixed(0)}m`;
                            document.getElementById('status-text').innerText = "Located";
                            document.getElementById('hud-coords').innerText = `${userPos[0].toFixed(4)}, ${userPos[1].toFixed(4)}`;
                            
                            // Update start point display
                            updateStartPointDisplay();
                            
                            // HIDE LOADER HERE
                            document.getElementById('loader').style.opacity = '0';
                            setTimeout(() => { 
                                document.getElementById('loader').style.display = 'none'; 
                                document.body.classList.add('ui-ready'); 
                                setupMapEvents();
                                
                                // Start continuous GPS AFTER permission is granted
                                setTimeout(() => {
                                    startContinuousGPS();
                                }, 1000);
                            }, 500);
                        },
                        (error) => { 
                            userPos = [40.7128, -74.0060];
                            userMarker.setLatLng(userPos);
                            map.setView(userPos, 2);
                            document.getElementById('status-text').innerText = "GPS Unavailable";
                            
                            // Update start point display
                            updateStartPointDisplay();
                            
                            // HIDE LOADER HERE TOO
                            document.getElementById('loader').style.opacity = '0';
                            setTimeout(() => { 
                                document.getElementById('loader').style.display = 'none'; 
                                document.body.classList.add('ui-ready'); 
                                setupMapEvents();
                            }, 500);
                        },
                        { 
                            enableHighAccuracy: true,
                            timeout: 60000,
                            maximumAge: 0
                        }
                    );
                } else {
                    userPos = [40.7128, -74.0060];
                    userMarker.setLatLng(userPos);
                    map.setView(userPos, 2);
                    
                    // Update start point display
                    updateStartPointDisplay();
                    
                    document.getElementById('loader').style.opacity = '0';
                    setTimeout(() => { 
                        document.getElementById('loader').style.display = 'none'; 
                        document.body.classList.add('ui-ready'); 
                        setupMapEvents();
                    }, 500);
                }
            }, 2000);
        };
        
        function startContinuousGPS() {
            // Don't start if we don't have permission or if already watching
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            // Start watching position silently (no permission prompt)
            watchId = navigator.geolocation.watchPosition(
                (pos) => {
                    userPos = [pos.coords.latitude, pos.coords.longitude];
                    
                    // Update marker position
                    userMarker.setLatLng(userPos);
                    
                    // Update start point display if using current location
                    if (customStartMode === 'current') {
                        updateStartPointDisplay();
                    }
                    
                    // Update HUD - only if not navigating
                    if (!isNavigating) {
                        document.getElementById('hud-precision').innerText = `${pos.coords.accuracy.toFixed(0)}m`;
                        document.getElementById('hud-coords').innerText = 
                            `${userPos[0].toFixed(4)}, ${userPos[1].toFixed(4)}`;
                    }
                    
                    // Check navigation progress
                    if (isNavigating && currentNavRoute) {
                        checkNavigationProgress(pos);
                    }
                },
                (error) => {
                    console.log("GPS watch error:", error);
                    // Don't retry continuously if permission is denied
                },
                { 
                    enableHighAccuracy: true,
                    maximumAge: 5000, // 5 seconds
                    timeout: 15000 // 15 second timeout
                }
            );
        }
        
        async function triggerAnalysis(lat, lng) {
            selectedTarget = [lat, lng];
            const sidebar = document.getElementById('info-sidebar');
            sidebar.classList.add('active');
            routeLayer.clearLayers();
            document.getElementById('start-nav-btn').classList.add('hidden');
            updateDestinationMarker(lat, lng);
            
            document.getElementById('side-title').innerText = "Processing...";
            
            try {
                const res = await fetch(`https://photon.komoot.io/reverse?lon=${lng}&lat=${lat}&limit=1`);
                const data = await res.json();
                
                if (data.features && data.features.length > 0) {
                    const p = data.features[0].properties || {};
                    const locationName = p.name || p.street || "Selected Location";
                    document.getElementById('side-title').innerText = 
                        p.name || p.street || "Selected Location";
                    document.getElementById('sidebar-content').innerHTML = `
                        <div class="space-y-6">
                            <div id="logistics-module">
                                <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block mb-4">Routes via Engine</span>
                                <div id="route-options" class="flex flex-col gap-2"></div>
                            </div>
                            <div class="space-y-2">
                                <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block">Address</span>
                                <p class="text-xs text-neutral-400 leading-relaxed">${[p.street, p.city, p.country, p.postcode].filter(Boolean).join(', ') || `${lat.toFixed(6)}, ${lng.toFixed(6)}`}</p>
                            </div>
                        </div>
                    `;

                    updateDestinationMarker(lat, lng, locationName);
                } else {
                    document.getElementById('side-title').innerText = "Location";
                    document.getElementById('sidebar-content').innerHTML = `
                        <div class="space-y-6">
                            <div id="logistics-module">
                                <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block mb-4">Routes via Engine</span>
                                <div id="route-options" class="flex flex-col gap-2"></div>
                            </div>
                            <div class="space-y-2">
                                <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block">Address</span>
                                <p class="text-xs text-neutral-400 leading-relaxed">${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            </div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error("Reverse geocoding failed:", error);
                document.getElementById('side-title').innerText = "Target Location";
                document.getElementById('sidebar-content').innerHTML = `
                    <div class="space-y-6">
                        <div id="logistics-module">
                            <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block mb-4">Routes via Engine</span>
                            <div id="route-options" class="flex flex-col gap-2"></div>
                        </div>
                        <div class="space-y-2">
                            <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block">Address</span>
                            <p class="text-xs text-neutral-400 leading-relaxed">${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                        </div>
                    </div>
                `;
            }
            
            // Use current start point (which could be custom or current location)
            calculateRoutes(getCurrentStartPoint(), [lat, lng]);
        }
        
        // (Note: The calculateRoutes function has been updated above to use calculateRealRoutes)
        
        async function fetchGraphHopperRoute(start, end, mode) {
            try {
                // GraphHopper supports long distances better
                const vehicle = mode === 'driving' ? 'car' : 
                               mode === 'cycling' ? 'bike' : 'foot';
                
                const response = await fetch(
                    `https://graphhopper.com/api/1/route?point=${start[0]},${start[1]}&point=${end[0]},${end[1]}&vehicle=${vehicle}&locale=en&instructions=true&points_encoded=false&key=demo`
                );
                
                const data = await response.json();
                
                if (data.paths && data.paths.length > 0) {
                    return {
                        distance: data.paths[0].distance,
                        duration: data.paths[0].time / 1000, // Convert ms to seconds
                        geometry: {
                            type: "LineString",
                            coordinates: data.paths[0].points.coordinates
                        },
                        legs: []
                    };
                }
                
                throw new Error('GraphHopper no route');
                
            } catch (error) {
                console.error(`GraphHopper ${mode} failed:`, error);
                throw error; // Let caller handle
            }
        }

        async function getICOAirports() {
            try {
                // ICAO maintains a list of international airports
                // Use multiple sources to get comprehensive list
                
                // Source 1: World Airport Codes (scraped data)
                const response = await fetch('https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat');
                const data = await response.text();
                
                const airports = [];
                const lines = data.split('\n');
                
                for (const line of lines) {
                    if (!line.trim()) continue;
                    
                    const fields = line.split(',');
                    if (fields.length >= 14) {
                        const name = fields[1].replace(/"/g, '');
                        const city = fields[2].replace(/"/g, '');
                        const country = fields[3].replace(/"/g, '');
                        const iata = fields[4].replace(/"/g, '');
                        const icao = fields[5].replace(/"/g, '');
                        const lat = parseFloat(fields[6]);
                        const lng = parseFloat(fields[7]);
                        
                        // Filter for significant airports
                        if (iata && iata.length === 3 && 
                            !isNaN(lat) && !isNaN(lng) &&
                            // Exclude tiny/specialized airports
                            (icao || name.includes('International') || name.includes('Airport'))) {
                            
                            airports.push({
                                code: iata,
                                icao: icao,
                                name: name,
                                city: city,
                                country: country,
                                coordinates: [lat, lng],
                                size: estimateAirportSize(name, city, country)
                            });
                        }
                    }
                }
                
                // Additional filtering to remove military/small airports
                const filteredAirports = airports.filter(airport => {
                    const name = airport.name.toLowerCase();
                    const isMajor = (
                        // Include international airports
                        name.includes('international') ||
                        // Include major city airports
                        (airport.size === 'large' || airport.size === 'medium') ||
                        // Include airports serving cities > 100k population
                        isMajorCity(airport.city, airport.country)
                    );
                    
                    const isMilitary = (
                        name.includes('air force') ||
                        name.includes('space force') ||
                        name.includes('naval') ||
                        name.includes('army') ||
                        name.includes('military') ||
                        name.includes('afb') ||
                        name.includes('airbase') ||
                        airport.code.includes('X') || // Many military codes end with X
                        name.includes('air station')
                    );
                    
                    return isMajor && !isMilitary;
                });
                
                console.log(`Filtered to ${filteredAirports.length} major commercial airports`);
                return filteredAirports;
                
            } catch (error) {
                console.error("ICAO data failed:", error);
                return getVerifiedCommercialAirports();
            }
        }

        function estimateAirportSize(name, city, country) {
            const nameLower = name.toLowerCase();
            
            if (nameLower.includes('international') || 
                ['JFK', 'LAX', 'LHR', 'CDG', 'DXB', 'SIN', 'HND', 'PEK', 'PVG'].some(code => 
                    name.includes(code))) {
                return 'large';
            }
            
            // Medium airports typically serve medium cities
            if (nameLower.includes('regional') || 
                nameLower.includes('municipal') ||
                cityPopulationLookup(city, country) > 500000) {
                return 'medium';
            }
            
            return 'small';
        }

        async function findBestAirportForRoute(startCoords, endCoords) {
    const airports = await getCommercialAirports();
    
    // Find airports near start - PRIORITIZE MAJOR AIRPORTS
    const startAirports = airports
        .map(airport => ({
            ...airport,
            distance: map.distance(startCoords, airport.coordinates),
            // Score based on size and distance
            score: calculateAirportScore(airport, startCoords)
        }))
        .filter(a => a.distance < 150000) // Within 150km
        .sort((a, b) => b.score - a.score); // Higher score first
    
    // Find airports near end
    const endAirports = airports
        .map(airport => ({
            ...airport,
            distance: map.distance(endCoords, airport.coordinates),
            score: calculateAirportScore(airport, endCoords)
        }))
        .filter(a => a.distance < 150000)
        .sort((a, b) => b.score - a.score);
    
    // Only suggest flight if we have decent airports
    if (startAirports.length === 0 || endAirports.length === 0) {
        return null;
    }
    
    const startAirport = startAirports[0];
    const endAirport = endAirports[0];
    
    // Don't suggest if airports are too close together
    const airportDistance = map.distance(startAirport.coordinates, endAirport.coordinates);
    if (airportDistance < 300000) { // Less than 300km
        return null;
    }
    
    return { start: startAirport, end: endAirport };
}

function calculateAirportScore(airport, userCoords) {
    const distance = map.distance(userCoords, airport.coordinates);
    
    // Base score based on airport importance
    let score = 0;
    
    // MAJOR INTERNATIONAL AIRPORTS get huge bonus
    if (isMajorInternationalAirport(airport)) {
        score += 500; // Large bonus for major airports
    }
    
    // Size-based scoring
    if (airport.size === 'large') score += 200;
    else if (airport.size === 'medium') score += 100;
    else if (airport.size === 'small') score += 50;
    
    // International designation bonus
    if (airport.name.toLowerCase().includes('international')) {
        score += 150;
    }
    
    // Specific major airport codes get extra priority
    const majorAirportCodes = ['SEA', 'JFK', 'LAX', 'ORD', 'DFW', 'LHR', 'CDG', 'FRA', 'AMS', 'HND', 'PEK', 'PVG'];
    if (majorAirportCodes.includes(airport.code)) {
        score += 300;
    }
    
    // Distance penalty (closer is better, but not as important as airport size)
    const distancePenalty = distance / 1000; // 1 point per km
    score -= distancePenalty;
    
    return score;
}

function isMajorInternationalAirport(airport) {
    // List of major international airport codes
    const majorInternationalAirports = [
        'ATL','LAX','ORD','DFW','DEN','JFK','SFO','SEA','LAS','MCO','MIA','CLT','EWR','PHX',
'IAH','BOS','MSP','DTW','PHL','SAN','TPA','PDX','BWI','IAD','DCA','SJC','OAK',
'AUS','SAT','DAL','HOU','CLE','CMH','CVG','IND','STL','MCI','SMF','SNA','ONT',
'BUR','LGB','PSP','RNO','BOI','SLC','ABQ','ELP','TUS','OKC','TUL','OMA','DSM',
'MSY','BTR','GPT','MOB','BHM','HSV','CHA','TYS','AVL','GSP','CAE','CHS','SAV',
'JAX','RSW','PBI','FLL','EYW','ORF','RIC','ROA','LYH','GSO','RDU','ILM', 'YYZ','YVR','YUL','YYC','YEG','YOW','YWG','YHZ','YQB','YYT','YXE','YLW', 'MEX','CUN','GDL','MTY','TIJ','SJD','PVR','MZT','HMO','LAP','LHR','LGW','STN','LTN','MAN','EDI','GLA','BHX','BRS','DUB','SNN','ORK','CDG','ORY','NCE','LYS','MRS','TLS','BOD','AMS','BRU','CRL','MAD','BCN','PMI','AGP','ALC','SVQ','BIO','FCO','MXP','LIN','BGY','VCE','NAP','CTA','PMO','BLQ','FCO','MXP','LIN','BGY','VCE','NAP','CTA','PMO','BLQ','ZRH','GVA','BSL','VIE','SZG','INN','ARN','OSL','CPH','HEL','GOT','TRD','SVG','TMP','ATH','SKG','HER','CFU','BEG','ZAG','LJU','SJJ','TIA','SOF','IST','SAW','AYT','ADB','HND','NRT','KIX','ITM','NGO','FUK','CTS','OKA','PEK','PKX','PVG','SHA','CAN','SZX','CTU','XIY','HGH','NKG',
'WUH','CSX','KMG','URC','TSN','CGO','ICN','GMP','PUS','CJU','SIN','HKG','BKK','DMK','HKT','CNX','DEL','BOM','BLR','MAA','HYD','CCU','COK','TRV','AMD','PNQ','KUL','PEN','CGK','DPS','SUB','MNL','CEB','DVO','TPE','KHH','SGN','HAN','DAD','DXB','DWC','AUH','SHJ','DOH','RUH','JED','DMM','KWI',
'BAH','MCT','AMM','TLV','BEY','CAI','JNB','CPT','DUR','PLZ','LOS','ABV','ACC','ADD','NBO',
'DAR','KGL','EBB','CMN','RAK','TUN','ALG','TIP','CAI','GRU','CGH','GIG','BSB','CNF','SSA','REC','FOR',
'EZE','AEP','COR','MDZ','SCL','LIM','BOG','MDE',
'UIO','GYE','CCS','PTY','MVD','ASU','LPB','VVI','SYD','MEL','BNE','PER','ADL','CBR','OOL','CNS',
'AKL','WLG','CHC','ZQN','NAN','PPT'
    ];
    
    return majorInternationalAirports.includes(airport.code) || 
           airport.name.toLowerCase().includes('international') ||
           airport.size === 'large';
}

        function getCommercialAirports() {
            // Curated list of verified commercial airports
            return [
                // US Major Hubs
                { code: "ATL", name: "Hartsfield-Jackson Atlanta International", city: "Atlanta", country: "USA", coordinates: [33.6407, -84.4277], size: "large" },
                { code: "LAX", name: "Los Angeles International", city: "Los Angeles", country: "USA", coordinates: [33.9416, -118.4085], size: "large" },
                { code: "ORD", name: "O'Hare International", city: "Chicago", country: "USA", coordinates: [41.9742, -87.9073], size: "large" },
                { code: "DFW", name: "Dallas/Fort Worth International", city: "Dallas", country: "USA", coordinates: [32.8998, -97.0403], size: "large" },
                { code: "DEN", name: "Denver International", city: "Denver", country: "USA", coordinates: [39.8561, -104.6737], size: "large" },
                { code: "JFK", name: "John F. Kennedy International", city: "New York", country: "USA", coordinates: [40.6413, -73.7781], size: "large" },
                { code: "SFO", name: "San Francisco International", city: "San Francisco", country: "USA", coordinates: [37.6213, -122.3790], size: "large" },
                { code: "SEA", name: "Seattle-Tacoma International", city: "Seattle", country: "USA", coordinates: [47.4502, -122.3088], size: "large" },
                { code: "LAS", name: "Harry Reid International", city: "Las Vegas", country: "USA", coordinates: [36.0840, -115.1537], size: "large" },
                { code: "MCO", name: "Orlando International", city: "Orlando", country: "USA", coordinates: [28.4294, -81.3090], size: "large" },
                
                // US Regional (but still commercial)
                { code: "PDX", name: "Portland International", city: "Portland", country: "USA", coordinates: [45.5887, -122.5975], size: "medium" },
                { code: "AUS", name: "Austin-Bergstrom International", city: "Austin", country: "USA", coordinates: [30.1975, -97.6664], size: "medium" },
                { code: "BNA", name: "Nashville International", city: "Nashville", country: "USA", coordinates: [36.1245, -86.6782], size: "medium" },
                { code: "SLC", name: "Salt Lake City International", city: "Salt Lake City", country: "USA", coordinates: [40.7884, -111.9778], size: "medium" },
                { code: "MSP", name: "Minneapolis-Saint Paul International", city: "Minneapolis", country: "USA", coordinates: [44.8820, -93.2218], size: "large" },
                { code: "DTW", name: "Detroit Metropolitan", city: "Detroit", country: "USA", coordinates: [42.2124, -83.3534], size: "large" },
                { code: "BOS", name: "Logan International", city: "Boston", country: "USA", coordinates: [42.3643, -71.0052], size: "large" },
                { code: "MIA", name: "Miami International", city: "Miami", country: "USA", coordinates: [25.7959, -80.2870], size: "large" },
                { code: "PHX", name: "Phoenix Sky Harbor International", city: "Phoenix", country: "USA", coordinates: [33.4343, -112.0081], size: "large" },
                { code: "IAH", name: "George Bush Intercontinental", city: "Houston", country: "USA", coordinates: [29.9844, -95.3414], size: "large" },
                
                // Canada
                { code: "YYZ", name: "Toronto Pearson International", city: "Toronto", country: "Canada", coordinates: [43.6777, -79.6248], size: "large" },
                { code: "YVR", name: "Vancouver International", city: "Vancouver", country: "Canada", coordinates: [49.1947, -123.1792], size: "large" },
                { code: "YUL", name: "MontrÃ©al-Trudeau International", city: "Montreal", country: "Canada", coordinates: [45.4706, -73.7408], size: "large" },
                { code: "YYC", name: "Calgary International", city: "Calgary", country: "Canada", coordinates: [51.1215, -114.0076], size: "large" },
                
                // Europe - Major
                { code: "LHR", name: "London Heathrow", city: "London", country: "UK", coordinates: [51.4700, -0.4543], size: "large" },
                { code: "CDG", name: "Paris Charles de Gaulle", city: "Paris", country: "France", coordinates: [49.0097, 2.5479], size: "large" },
                { code: "AMS", name: "Amsterdam Schiphol", city: "Amsterdam", country: "Netherlands", coordinates: [52.3086, 4.7639], size: "large" },
                { code: "FRA", name: "Frankfurt Airport", city: "Frankfurt", country: "Germany", coordinates: [50.0333, 8.5706], size: "large" },
                { code: "IST", name: "Istanbul Airport", city: "Istanbul", country: "Turkey", coordinates: [41.2622, 28.7425], size: "large" },
                { code: "MAD", name: "Madrid Barajas", city: "Madrid", country: "Spain", coordinates: [40.4983, -3.5676], size: "large" },
                { code: "FCO", name: "Rome Fiumicino", city: "Rome", country: "Italy", coordinates: [41.8045, 12.2508], size: "large" },
                { code: "BCN", name: "Barcelona El Prat", city: "Barcelona", country: "Spain", coordinates: [41.2974, 2.0833], size: "large" },
                { code: "MUC", name: "Munich Airport", city: "Munich", country: "Germany", coordinates: [48.3538, 11.7861], size: "large" },
                { code: "ZRH", name: "Zurich Airport", city: "Zurich", country: "Switzerland", coordinates: [47.4647, 8.5492], size: "large" },
                
                // Asia - Major
                { code: "PEK", name: "Beijing Capital International", city: "Beijing", country: "China", coordinates: [40.0799, 116.6031], size: "large" },
                { code: "PVG", name: "Shanghai Pudong International", city: "Shanghai", country: "China", coordinates: [31.1434, 121.8052], size: "large" },
                { code: "HND", name: "Tokyo Haneda", city: "Tokyo", country: "Japan", coordinates: [35.5494, 139.7798], size: "large" },
                { code: "SIN", name: "Singapore Changi", city: "Singapore", country: "Singapore", coordinates: [1.3644, 103.9915], size: "large" },
                { code: "ICN", name: "Seoul Incheon International", city: "Seoul", country: "South Korea", coordinates: [37.4602, 126.4407], size: "large" },
                { code: "BKK", name: "Bangkok Suvarnabhumi", city: "Bangkok", country: "Thailand", coordinates: [13.6811, 100.7475], size: "large" },
                { code: "DEL", name: "Delhi Indira Gandhi International", city: "Delhi", country: "India", coordinates: [28.5562, 77.1000], size: "large" },
                { code: "DXB", name: "Dubai International", city: "Dubai", country: "UAE", coordinates: [25.2532, 55.3657], size: "large" },
                { code: "HKG", name: "Hong Kong International", city: "Hong Kong", country: "China", coordinates: [22.3080, 113.9185], size: "large" },
                
                // Rest of World
                { code: "SYD", name: "Sydney Kingsford Smith", city: "Sydney", country: "Australia", coordinates: [-33.9399, 151.1753], size: "large" },
                { code: "MEL", name: "Melbourne Airport", city: "Melbourne", country: "Australia", coordinates: [-37.6733, 144.8433], size: "large" },
                { code: "AKL", name: "Auckland Airport", city: "Auckland", country: "New Zealand", coordinates: [-37.0081, 174.7925], size: "large" },
                { code: "GRU", name: "SÃ£o Paulo Guarulhos", city: "SÃ£o Paulo", country: "Brazil", coordinates: [-23.4356, -46.4731], size: "large" },
                { code: "EZE", name: "Buenos Aires Ezeiza", city: "Buenos Aires", country: "Argentina", coordinates: [-34.8222, -58.5358], size: "large" },
                { code: "JNB", name: "Johannesburg O.R. Tambo", city: "Johannesburg", country: "South Africa", coordinates: [-26.1392, 28.2460], size: "large" },
                { code: "CAI", name: "Cairo International", city: "Cairo", country: "Egypt", coordinates: [30.1219, 31.4056], size: "large" },
                { code: "TLV", name: "Ben Gurion Airport", city: "Tel Aviv", country: "Israel", coordinates: [32.0114, 34.8867], size: "large" }
            ];
        }
        
        function getMajorAirportsList() {
            return [
                // NORTH AMERICA
                { code: "JFK", name: "John F. Kennedy International", coords: [40.6413, -73.7781], city: "New York" },
                { code: "LAX", name: "Los Angeles International", coords: [33.9416, -118.4085], city: "Los Angeles" },
                { code: "ORD", name: "O'Hare International", coords: [41.9742, -87.9073], city: "Chicago" },
                { code: "DFW", name: "Dallas/Fort Worth International", coords: [32.8998, -97.0403], city: "Dallas" },
                { code: "DEN", name: "Denver International", coords: [39.8561, -104.6737], city: "Denver" },
                { code: "SFO", name: "San Francisco International", coords: [37.6213, -122.3790], city: "San Francisco" },
                { code: "SEA", name: "Seattle-Tacoma International", coords: [47.4502, -122.3088], city: "Seattle" },
                { code: "MIA", name: "Miami International", coords: [25.7959, -80.2870], city: "Miami" },
                { code: "ATL", name: "Hartsfield-Jackson Atlanta", coords: [33.6407, -84.4277], city: "Atlanta" },
                { code: "YYZ", name: "Toronto Pearson", coords: [43.6777, -79.6248], city: "Toronto" },
                { code: "YVR", name: "Vancouver International", coords: [49.1947, -123.1792], city: "Vancouver" },
                { code: "MEX", name: "Mexico City International", coords: [19.4363, -99.0721], city: "Mexico City" },
                
                // EUROPE
                { code: "LHR", name: "London Heathrow", coords: [51.4700, -0.4543], city: "London" },
                { code: "CDG", name: "Paris Charles de Gaulle", coords: [49.0097, 2.5479], city: "Paris" },
                { code: "FRA", name: "Frankfurt Airport", coords: [50.0333, 8.5706], city: "Frankfurt" },
                { code: "AMS", name: "Amsterdam Schiphol", coords: [52.3086, 4.7639], city: "Amsterdam" },
                { code: "MAD", name: "Madrid Barajas", coords: [40.4983, -3.5676], city: "Madrid" },
                { code: "FCO", name: "Rome Fiumicino", coords: [41.8045, 12.2508], city: "Rome" },
                { code: "BCN", name: "Barcelona El Prat", coords: [41.2974, 2.0833], city: "Barcelona" },
                { code: "ZRH", name: "Zurich Airport", coords: [47.4647, 8.5492], city: "Zurich" },
                { code: "IST", name: "Istanbul Airport", coords: [41.2622, 28.7425], city: "Istanbul" },
                { code: "DUB", name: "Dublin Airport", coords: [53.4213, -6.2701], city: "Dublin" },
                
                // ASIA
                { code: "HND", name: "Tokyo Haneda", coords: [35.5494, 139.7798], city: "Tokyo" },
                { code: "NRT", name: "Tokyo Narita", coords: [35.7647, 140.3864], city: "Tokyo" },
                { code: "PEK", name: "Beijing Capital", coords: [40.0799, 116.6031], city: "Beijing" },
                { code: "PVG", name: "Shanghai Pudong", coords: [31.1434, 121.8052], city: "Shanghai" },
                { code: "HKG", name: "Hong Kong International", coords: [22.3080, 113.9185], city: "Hong Kong" },
                { code: "SIN", name: "Singapore Changi", coords: [1.3644, 103.9915], city: "Singapore" },
                { code: "BKK", name: "Bangkok Suvarnabhumi", coords: [13.6811, 100.7475], city: "Bangkok" },
                { code: "DEL", name: "Delhi Indira Gandhi", coords: [28.5562, 77.1000], city: "Delhi" },
                { code: "ICN", name: "Seoul Incheon", coords: [37.4602, 126.4407], city: "Seoul" },
                { code: "DOH", name: "Doha Hamad International", coords: [25.2609, 51.6138], city: "Doha" },
                
                // AUSTRALIA/PACIFIC
                { code: "SYD", name: "Sydney Kingsford Smith", coords: [-33.9399, 151.1753], city: "Sydney" },
                { code: "MEL", name: "Melbourne Airport", coords: [-37.6733, 144.8433], city: "Melbourne" },
                { code: "AKL", name: "Auckland Airport", coords: [-37.0081, 174.7925], city: "Auckland" },
                
                // SOUTH AMERICA
                { code: "GRU", name: "SÃ£o Paulo Guarulhos", coords: [-23.4356, -46.4731], city: "SÃ£o Paulo" },
                { code: "EZE", name: "Buenos Aires Ezeiza", coords: [-34.8222, -58.5358], city: "Buenos Aires" },
                { code: "SCL", name: "Santiago Arturo Merino BenÃ­tez", coords: [-33.3930, -70.7858], city: "Santiago" },
                { code: "LIM", name: "Lima Jorge ChÃ¡vez", coords: [-12.0219, -77.1143], city: "Lima" },
                
                // AFRICA
                { code: "JNB", name: "Johannesburg O.R. Tambo", coords: [-26.1392, 28.2460], city: "Johannesburg" },
                { code: "CAI", name: "Cairo International", coords: [30.1219, 31.4056], city: "Cairo" },
                { code: "ADD", name: "Addis Ababa Bole", coords: [8.9779, 38.7993], city: "Addis Ababa" },
                { code: "MBA", name: "Mombasa Moi International", coords: [-4.0348, 39.5942], city: "Mombasa" },
                
                // MIDDLE EAST
                { code: "DXB", name: "Dubai International", coords: [25.2532, 55.3657], city: "Dubai" },
                { code: "AUH", name: "Abu Dhabi International", coords: [24.4330, 54.6511], city: "Abu Dhabi" },
                { code: "RUH", name: "Riyadh King Khalid", coords: [24.9584, 46.6989], city: "Riyadh" },
                { code: "TLV", name: "Tel Aviv Ben Gurion", coords: [32.0114, 34.8867], city: "Tel Aviv" }
            ];
        }
        
        async function findNearestMajorAirport(coords) {
            const majorAirports = getMajorAirportsList();
            
            // Find airports sorted by distance
            const airportsWithDistance = majorAirports.map(airport => {
                const distance = map.distance(coords, airport.coords);
                return { ...airport, distance };
            });
            
            // Sort by distance
            airportsWithDistance.sort((a, b) => a.distance - b.distance);
            
            // Filter out airports that are TOO far (>500km)
            const nearbyAirports = airportsWithDistance.filter(a => a.distance <= 500000);
            
            if (nearbyAirports.length === 0) {
                // No airport within 500km, return nothing (don't show flight option)
                return null;
            }
            
            return {
                name: nearbyAirports[0].name,
                code: nearbyAirports[0].code,
                city: nearbyAirports[0].city,
                coordinates: nearbyAirports[0].coords,
                distance: nearbyAirports[0].distance
            };
        }

        // Global cache for airport data
        let airportCache = null;
        const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

        async function getAirportDatabase() {
            // Return cached data if available
            if (airportCache && (Date.now() - airportCache.timestamp) < CACHE_DURATION) {
                return airportCache.data;
            }
            
            try {
                // Try OurAirports first (most reliable)
                const airports = await getAllAirports();
                
                // Cache the results
                airportCache = {
                    timestamp: Date.now(),
                    data: airports
                };
                
                // Also save to localStorage for offline use
                try {
                    localStorage.setItem('airportData', JSON.stringify({
                        timestamp: Date.now(),
                        data: airports.slice(0, 5000) // Store first 5000 airports
                    }));
                } catch (e) {
                    // localStorage might be full, that's okay
                }
                
                return airports;
                
            } catch (error) {
                console.error("Airport database failed, trying fallbacks...");
                
                // Try localStorage cache
                try {
                    const cached = JSON.parse(localStorage.getItem('airportData'));
                    if (cached && cached.data) {
                        return cached.data;
                    }
                } catch (e) {
                    // localStorage failed
                }
                
                // Final fallback: minimal essential airports
                return getEssentialAirports();
            }
        }

        async function findNearestAirport(coords, maxDistance = 200000) {
            const airports = await getAirportDatabase();
            const [lat, lng] = coords;
            
            let nearest = null;
            let minDistance = Infinity;
            
            for (const airport of airports) {
                const distance = map.distance([lat, lng], airport.coordinates);
                
                if (distance < minDistance && distance < maxDistance) {
                    minDistance = distance;
                    nearest = {
                        ...airport,
                        distance: distance
                    };
                }
            }
            
            return nearest;
        }

        function getEssentialAirports() {
            // Hand-picked list of major worldwide airports
            return [
                // NORTH AMERICA
                { code: "ATL", name: "Hartsfield-Jackson Atlanta International", city: "Atlanta", country: "USA", coordinates: [33.6407, -84.4277] },
                { code: "LAX", name: "Los Angeles International", city: "Los Angeles", country: "USA", coordinates: [33.9416, -118.4085] },
                { code: "ORD", name: "O'Hare International", city: "Chicago", country: "USA", coordinates: [41.9742, -87.9073] },
                { code: "DFW", name: "Dallas/Fort Worth International", city: "Dallas", country: "USA", coordinates: [32.8998, -97.0403] },
                { code: "DEN", name: "Denver International", city: "Denver", country: "USA", coordinates: [39.8561, -104.6737] },
                { code: "JFK", name: "John F. Kennedy International", city: "New York", country: "USA", coordinates: [40.6413, -73.7781] },
                { code: "SFO", name: "San Francisco International", city: "San Francisco", country: "USA", coordinates: [37.6213, -122.3790] },
                { code: "SEA", name: "Seattle-Tacoma International", city: "Seattle", country: "USA", coordinates: [47.4502, -122.3088] },
                { code: "YYZ", name: "Toronto Pearson International", city: "Toronto", country: "Canada", coordinates: [43.6777, -79.6248] },
                { code: "MEX", name: "Mexico City International", city: "Mexico City", country: "Mexico", coordinates: [19.4363, -99.0721] },
                
                // EUROPE
                { code: "LHR", name: "London Heathrow", city: "London", country: "UK", coordinates: [51.4700, -0.4543] },
                { code: "CDG", name: "Paris Charles de Gaulle", city: "Paris", country: "France", coordinates: [49.0097, 2.5479] },
                { code: "AMS", name: "Amsterdam Schiphol", city: "Amsterdam", country: "Netherlands", coordinates: [52.3086, 4.7639] },
                { code: "FRA", name: "Frankfurt Airport", city: "Frankfurt", country: "Germany", coordinates: [50.0333, 8.5706] },
                { code: "IST", name: "Istanbul Airport", city: "Istanbul", country: "Turkey", coordinates: [41.2622, 28.7425] },
                { code: "MAD", name: "Madrid Barajas", city: "Madrid", country: "Spain", coordinates: [40.4983, -3.5676] },
                { code: "FCO", name: "Rome Fiumicino", city: "Rome", country: "Italy", coordinates: [41.8045, 12.2508] },
                
                // ASIA
                { code: "PEK", name: "Beijing Capital International", city: "Beijing", country: "China", coordinates: [40.0799, 116.6031] },
                { code: "HND", name: "Tokyo Haneda", city: "Tokyo", country: "Japan", coordinates: [35.5494, 139.7798] },
                { code: "PVG", name: "Shanghai Pudong International", city: "Shanghai", country: "China", coordinates: [31.1434, 121.8052] },
                { code: "DXB", name: "Dubai International", city: "Dubai", country: "UAE", coordinates: [25.2532, 55.3657] },
                { code: "SIN", name: "Singapore Changi", city: "Singapore", country: "Singapore", coordinates: [1.3644, 103.9915] },
                { code: "BKK", name: "Bangkok Suvarnabhumi", city: "Bangkok", country: "Thailand", coordinates: [13.6811, 100.7475] },
                { code: "ICN", name: "Seoul Incheon International", city: "Seoul", country: "South Korea", coordinates: [37.4602, 126.4407] },
                { code: "DEL", name: "Delhi Indira Gandhi International", city: "Delhi", country: "India", coordinates: [28.5562, 77.1000] },
                
                // OCEANIA
                { code: "SYD", name: "Sydney Kingsford Smith", city: "Sydney", country: "Australia", coordinates: [-33.9399, 151.1753] },
                { code: "MEL", name: "Melbourne Airport", city: "Melbourne", country: "Australia", coordinates: [-37.6733, 144.8433] },
                { code: "AKL", name: "Auckland Airport", city: "Auckland", country: "New Zealand", coordinates: [-37.0081, 174.7925] },
                
                // SOUTH AMERICA
                { code: "GRU", name: "SÃ£o Paulo Guarulhos", city: "SÃ£o Paulo", country: "Brazil", coordinates: [-23.4356, -46.4731] },
                { code: "EZE", name: "Buenos Aires Ezeiza", city: "Buenos Aires", country: "Argentina", coordinates: [-34.8222, -58.5358] },
                
                // AFRICA
                { code: "JNB", name: "Johannesburg O.R. Tambo", city: "Johannesburg", country: "South Africa", coordinates: [-26.1392, 28.2460] },
                { code: "CAI", name: "Cairo International", city: "Cairo", country: "Egypt", coordinates: [30.1219, 31.4056] }
            ];
        }

        // Update shouldShowFlightRoute to be more restrictive
        function shouldShowFlightRoute(start, end, distance) {
            // Don't show flight for very short distances
            if (distance < 100000) return false; // Less than 100km
            
            // Don't show flight if origin and destination are in same city/metro area
            if (distance < 300000) { // Less than 300km
                // Check if both points are likely in same metro area
                const startAirport = findNearestMajorAirport(start);
                const endAirport = findNearestMajorAirport(end);
                
                if (startAirport && endAirport && startAirport.code === endAirport.code) {
                    return false; // Same airport, no flight needed
                }
            }
            
            // Show flight for distances over 300km OR when airports are available
            if (distance > 300000) return true;
            
            return false;
        }

        async function calculateFlightRoute(start, end, distance) {
            // Only consider flight for significant distances
            if (distance < 300000) return null; // Less than 300km
            
            const airports = await findBestAirportForRoute(start, end);
            if (!airports) return null;
            
            const { start: startAirport, end: endAirport } = airports;
            
            // Calculate actual travel distances
            const toAirportDistance = startAirport.distance;
            const airportToAirportDistance = map.distance(startAirport.coordinates, endAirport.coordinates);
            const fromAirportDistance = endAirport.distance;
            
            // Time calculations
            const groundSpeed = 30000; // 30 km/h for ground transport
            const flightSpeed = 800000; // 800 km/h for flight
            const airportTime = 7200; // 2 hours for airport processes
            
            const toAirportTime = (toAirportDistance / groundSpeed) * 3600;
            const flightTime = (airportToAirportDistance / flightSpeed) * 3600;
            const fromAirportTime = (fromAirportDistance / groundSpeed) * 3600;
            
            const totalTime = toAirportTime + flightTime + fromAirportTime + airportTime;
            
            // Only suggest flight if it's significantly better than driving
            const directDistance = map.distance(start, end);
            const drivingTime = (directDistance / 80000) * 3600; // 80 km/h average
            if (totalTime > drivingTime * 0.8) { // Less than 20% time saving
                return null;
            }
            
            return {
                id: 'flight',
                icon: 'lucide:plane',
                label: 'Flight',
                duration: totalTime,
                distance: airportToAirportDistance,
                geometry: createFlightPath(startAirport.coordinates, endAirport.coordinates),
                steps: [
                    {
                        distance: toAirportDistance,
                        duration: toAirportTime,
                        maneuver: {
                            instruction: `Travel to ${startAirport.code} Airport`,
                            type: 'ground'
                        }
                    },
                    {
                        distance: airportToAirportDistance,
                        duration: flightTime,
                        maneuver: {
                            instruction: `Fly from ${startAirport.code} to ${endAirport.code}`,
                            type: 'flight'
                        }
                    },
                    {
                        distance: fromAirportDistance,
                        duration: fromAirportTime,
                        maneuver: {
                            instruction: `Travel from ${endAirport.code} Airport to destination`,
                            type: 'ground'
                        }
                    }
                ],
                airports: {
                    departure: startAirport,
                    arrival: endAirport
                },
                groundTransport: {
                    toAirport: formatTime(toAirportTime),
                    fromAirport: formatTime(fromAirportTime)
                },
                details: `${startAirport.name} â ${endAirport.name}`
            };
        }
                        
        function processOSRMSteps(osrmSteps) {
            return osrmSteps.map((step, index) => {
                const instruction = generateRealNavigationInstruction(step, index, osrmSteps);
                
                return {
                    distance: step.distance,
                    duration: step.duration,
                    geometry: step.geometry,
                    maneuver: {
                        instruction: instruction,
                        type: step.maneuver?.type || 'continue',
                        modifier: step.maneuver?.modifier || '',
                        location: step.maneuver?.location
                    },
                    name: step.name || getStreetName(step),
                    way_points: step.way_points
                };
            });
        }

        function generateFlightBookingLinks(departure, arrival) {
            const links = [];
            
            // Only show booking links if we have airport codes
            if (departure.code && arrival.code) {
                links.push({
                    name: "Kayak",
                    url: `https://www.kayak.com/flights/${departure.code}-${arrival.code}`,
                    icon: "lucide:search"
                });
                
                links.push({
                    name: "Expedia",
                    url: `https://www.expedia.com/Flights-Search?flight-type=on&mode=search&trip=oneway&leg1=from:${departure.code},to:${arrival.code}`,
                    icon: "lucide:plane"
                });
                
                links.push({
                    name: "Google Flights",
                    url: `https://www.google.com/travel/flights?q=Flights%20to%20${arrival.code}%20from%20${departure.code}`,
                    icon: "lucide:globe"
                });
            } else {
                // Generic search if no airport codes
                const startName = departure.city || departure.name || "origin";
                const endName = arrival.city || arrival.name || "destination";
                
                links.push({
                    name: "Search Flights",
                    url: `https://www.google.com/search?q=flights+from+${encodeURIComponent(startName)}+to+${encodeURIComponent(endName)}`,
                    icon: "lucide:search"
                });
            }
            
            // Add car rental link
            links.push({
                name: "Car Rental",
                url: `https://www.rentalcars.com/`,
                icon: "lucide:car"
            });
            
            // Add hotel booking link
            links.push({
                name: "Hotels",
                url: `https://www.booking.com/`,
                icon: "lucide:building"
            });
            
            return links;
        }
        
        function createFlightPath(start, end) {
            // Create a curved flight path (great circle approximation)
            const midLat = (start[0] + end[0]) / 2;
            const midLng = (start[1] + end[1]) / 2;
            
            // Add a slight curve to the path (great circle arc)
            const curveFactor = 0.5;
            const curveLat = midLat + curveFactor;
            const curveLng = midLng + curveFactor;
            
            return {
                type: "LineString",
                coordinates: [
                    [start[1], start[0]],
                    [curveLng, curveLat],
                    [end[1], end[0]]
                ]
            };
        }
        
        function formatDistanceForInstructions(distance) {
            if (distance < 50) return "Soon";
            if (distance < 100) return "In 100 m";
            if (distance < 200) return "In 200 m";
            if (distance < 500) return "In 500 m";
            if (distance < 1000) return "In " + Math.round(distance/100)*100 + " m";
            return "in " + (distance/1000).toFixed(1) + " km";
        }
        
        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        
        function getStreetName(step) {
            return step.name || "";
        }
        
        function getOrdinal(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return s[(v - 20) % 10] || s[v] || s[0];
        }
        
        function calculateTrafficLevel(start, end) {
            const now = new Date();
            const hour = now.getHours();
            const distance = map.distance(start, end);
            
            // High traffic during rush hours
            if (distance < 50000 && ((hour >= 8 && hour <= 10) || (hour >= 16 && hour <= 19))) {
                return Math.random() > 0.5 ? 'high' : 'medium';
            }
            
            const rand = Math.random();
            if (rand > 0.7) return 'high';
            if (rand > 0.4) return 'medium';
            return 'low';
        }
        
        function addRouteCard(route) {
            const container = document.getElementById('route-options');
            const div = document.createElement('div');
            div.className = "route-card";
            div.dataset.routeId = route.id;
            
            const timeStr = formatTime(route.duration);
            const arrival = getArrival(route.duration);
            const distanceStr = (route.distance / 1000).toFixed(1) + ' km';
            
            let trafficIndicator = '';
            if (route.id === 'driving' && route.traffic) {
                const trafficClass = `traffic-${route.traffic}`;
                trafficIndicator = `<span class="traffic-indicator ${trafficClass}"></span>`;
            }

                if (route.id === 'flight') {
        // GENERATE BOOKING LINKS FOR FLIGHTS
        const bookingLinks = generateFlightBookingLinks(
            route.airports?.departure || {code: "???", city: "origin"}, 
            route.airports?.arrival || {code: "???", city: "destination"}
        );
        
        // Create HTML for booking links
        const bookingLinksHTML = bookingLinks.map(link => 
            `<a href="${link.url}" target="_blank" class="inline-flex items-center gap-1 text-[8px] text-sky-400 hover:text-sky-300 mr-3 border border-sky-400/30 rounded px-2 py-1 hover:bg-sky-400/10 transition-colors">
                <iconify-icon icon="${link.icon}" class="text-[10px]"></iconify-icon>
                ${link.name}
            </a>`
        ).join('');
        
        const totalTime = formatTime(route.duration);
        const flightTime = formatTime(route.flightTime || (route.duration * 0.6));
        
        div.innerHTML = `
            <div class="flex items-center gap-4">
                <iconify-icon icon="${route.icon}" class="text-2xl text-sky-500"></iconify-icon>
                <div class="flex-1">
                    <div class="flex justify-between items-center">
                        <div class="text-[10px] font-bold text-white">Flight Route</div>
                        <div class="text-[9px] font-bold text-sky-400">${(route.distance/1000).toFixed(0)} km</div>
                    </div>
                    <div class="text-[9px] text-sky-300 mb-1">${route.details || "Direct flight"}</div>
                    <div class="text-[9px] text-neutral-400 uppercase">${flightTime} flight â¢ ${totalTime} total</div>
                    <div class="mt-2 pt-2 border-t border-white/10">
                        <div class="text-[8px] text-neutral-500 uppercase mb-1">Book Travel:</div>
                        <div class="flex flex-wrap gap-1">
                            ${bookingLinksHTML}
                        </div>
                    </div>
                </div>
            </div>`;
    } else {
                div.innerHTML = `
                    <div class="flex items-center gap-4">
                        <iconify-icon icon="${route.icon}" class="text-xl text-neutral-500"></iconify-icon>
                        <div class="flex-1">
                            <div class="flex justify-between items-center">
                                <div class="text-[10px] font-bold text-white">${trafficIndicator}${route.label}</div>
                                <div class="text-[9px] font-bold text-emerald-400">${distanceStr}</div>
                            </div>
                            <div class="text-[9px] text-neutral-400 uppercase">${timeStr} â¢ Arr: ${arrival}</div>
                        </div>
                    </div>`;
            }
            
            div.onclick = () => {
                document.querySelectorAll('.route-card').forEach(c => c.classList.remove('active'));
                div.classList.add('active');
                currentRoute = route;
                renderPath(route);
            };
            container.appendChild(div);
        }
        
        function renderPath(route) {
            routeLayer.clearLayers();
            
            if (!route || !route.geometry) {
                console.error("No route geometry available");
                return;
            }
            
            // Set path color based on mode and traffic
            let color = '#10b981';
            let weight = 5;
            let dashArray = null;
            
            if (route.id === 'driving') {
                if (route.traffic === 'high') color = '#ef4444';
                else if (route.traffic === 'medium') color = '#f59e0b';
                else color = '#10b981';
            } else if (route.id === 'cycling') {
                color = '#3b82f6';
            } else if (route.id === 'walking') {
                color = '#8b5cf6';
                weight = 3;
            } else if (route.id === 'flight') {
                color = '#38bdf8'; // Sky blue
                weight = 3;
                dashArray = '10, 5'; // Dashed line for flight path
            }
            
            // Create GeoJSON feature
            const feature = {
                type: "Feature",
                geometry: route.geometry,
                properties: {}
            };
            
            L.geoJSON(feature, {
                style: { 
                    color: color, 
                    weight: weight, 
                    opacity: 0.8,
                    dashArray: dashArray
                }
            }).addTo(routeLayer);
            
            // Show start navigation button
            const startBtn = document.getElementById('start-nav-btn');
            startBtn.classList.remove('hidden');
            startBtn.onclick = () => startActiveNav(route);
        }
        
        function startActiveNav(route) {
            isNavigating = true;
            currentNavRoute = route;
            currentStepIndex = 0;
            totalRouteDistance = route.distance;
            routeStartTime = new Date();
            
            // Add navigating class to body for HUD styling
            document.body.classList.add('navigating');
            
            // Hide start button immediately
            document.getElementById('start-nav-btn').classList.add('hidden');
            
            document.getElementById('standard-ui').style.display = 'none';
            document.getElementById('active-nav-hud').style.display = 'flex';
            
            // Transform sidebar to directions list
            transformSidebarToDirections(route);
            
            // Update navigation display
            updateNavigationDisplay();
            
            // Update bottom HUD with ETA and distance
            updateNavigationHUD();
            
            // **GOOGLE/APPLE-STYLE NAVIGATION CAMERA**
            setupNavigationCamera(route);
            
            // Start navigation updates
            startNavigationUpdates();
        }

        function setupNavigationCamera(route) {
            if (!route || !route.geometry) return;
            
            // Get the route coordinates
            const coords = route.geometry.coordinates;
            if (coords.length < 2) return;
            
            // Convert to LatLng objects
            const latLngs = coords.map(coord => L.latLng(coord[1], coord[0]));
            
            // Calculate initial camera position
            const startPoint = getCurrentStartPoint();
            const startLatLng = L.latLng(startPoint[0], startPoint[1]);
            
            // Find the closest point on route to start
            let closestIndex = 0;
            let minDistance = Infinity;
            
            for (let i = 0; i < latLngs.length; i++) {
                const distance = startLatLng.distanceTo(latLngs[i]);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestIndex = i;
                }
            }
            
            // Look ahead 5 points for direction
            const lookAheadIndex = Math.min(closestIndex + 5, latLngs.length - 1);
            
            // Calculate bearing (direction)
            const bearing = calculateBearing(
                latLngs[closestIndex],
                latLngs[lookAheadIndex]
            );
            
            // Set up navigation view
            map.flyTo(latLngs[closestIndex], 18, {
                animate: true,
                duration: 1,
                easeLinearity: 0.25
            });
            
            // Store for navigation updates
            window.navigationCamera = {
                routePoints: latLngs,
                currentIndex: closestIndex,
                bearing: bearing
            };
            
            // Add route line with arrow markers
            showNavigationRoute(route);
        }

        function calculateBearing(point1, point2) {
            const lat1 = point1.lat * Math.PI / 180;
            const lat2 = point2.lat * Math.PI / 180;
            const lon1 = point1.lng * Math.PI / 180;
            const lon2 = point2.lng * Math.PI / 180;
            
            const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) -
                      Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
            
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            bearing = (bearing + 360) % 360;
            
            return bearing;
        }

        function showNavigationRoute(route) {
            // Clear existing route
            routeLayer.clearLayers();
            
            // Clear existing arrows
            if (window.routeArrows) {
                window.routeArrows.clearLayers();
            } else {
                window.routeArrows = L.layerGroup().addTo(map);
            }
            
            // Draw route with proper styling
            const routeLine = L.geoJSON(route.geometry, {
                style: {
                    color: '#3b82f6',
                    weight: 8,
                    opacity: 0.8,
                    lineCap: 'round',
                    lineJoin: 'round',
                    className: 'nav-route-line'
                }
            }).addTo(routeLayer);
            
            // Add outline for better visibility
            const routeOutline = L.geoJSON(route.geometry, {
                style: {
                    color: 'white',
                    weight: 12,
                    opacity: 0.5,
                    lineCap: 'round',
                    lineJoin: 'round',
                    className: 'nav-route-outline'
                }
            }).addTo(routeLayer);
            
            // Add direction arrows
            addDirectionArrows(route.geometry);
            
            // Add start and end markers
            addNavigationMarkers(route);
            
            // Add user position marker
            addUserPositionMarker();
        }

        function addDirectionArrows(geometry) {
            const coords = geometry.coordinates;
            const arrowCount = Math.min(30, Math.floor(coords.length / 5));
            
            // Clear existing arrows first
            if (window.routeArrows) {
                window.routeArrows.clearLayers();
            } else {
                window.routeArrows = L.layerGroup().addTo(map);
            }
            
            for (let i = 0; i < arrowCount; i++) {
                const index = Math.floor(i * (coords.length / arrowCount));
                if (index >= coords.length - 1) continue;
                
                const start = coords[index];
                const end = coords[Math.min(index + 1, coords.length - 1)];
                
                // Calculate direction
                const bearing = calculateBearing(
                    L.latLng(start[1], start[0]),
                    L.latLng(end[1], end[0])
                );
                
                // Create arrow icon with better visibility
                const arrowIcon = L.divIcon({
                    className: 'nav-arrow-icon',
                    html: `
                        <div style="
                            position: relative;
                            width: 24px;
                            height: 24px;
                            transform: rotate(${bearing}deg);
                        ">
                            <div style="
                                position: absolute;
                                width: 0;
                                height: 0;
                                border-left: 8px solid transparent;
                                border-right: 8px solid transparent;
                                border-bottom: 12px solid #3b82f6;
                                top: 0;
                                left: 4px;
                                filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
                            "></div>
                            <div style="
                                position: absolute;
                                width: 4px;
                                height: 10px;
                                background: #3b82f6;
                                top: 12px;
                                left: 10px;
                                border-radius: 2px;
                            "></div>
                        </div>
                    `,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                
                L.marker([start[1], start[0]], { 
                    icon: arrowIcon,
                    zIndexOffset: 1000
                }).addTo(window.routeArrows);
            }
        }

        function addNavigationMarkers(route) {
            // Start marker (if custom start)
            if (customStartMode !== 'current' && customStartPos) {
                const startIcon = L.divIcon({
                    className: 'nav-start-marker',
                    html: '<div style="background: #10b981; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 8px rgba(16, 185, 129, 0.7);"></div>',
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
                
                L.marker(customStartPos, { icon: startIcon })
                    .addTo(routeLayer)
                    .bindPopup('Start point');
            }
            
            // End marker
            if (selectedTarget) {
                const endIcon = L.divIcon({
                    className: 'nav-end-marker',
                    html: '<div style="background: #ef4444; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(239, 68, 68, 0.7); position: relative;"><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 6px; height: 6px; background: white; border-radius: 50%;"></div></div>',
                    iconSize: [22, 22],
                    iconAnchor: [11, 11]
                });
                
                L.marker(selectedTarget, { icon: endIcon })
                    .addTo(routeLayer)
                    .bindPopup('Destination');
            }
        }

        function startNavigationUpdates() {
            // Clear any existing interval
            if (window.navUpdateInterval) {
                clearInterval(window.navUpdateInterval);
            }
            
            let isUserMovingMap = false;
            let mapMoveTimeout;
            
            // Track when user is moving the map
            map.on('movestart', () => {
                isUserMovingMap = true;
                clearTimeout(mapMoveTimeout);
            });
            
            map.on('moveend', () => {
                // Wait a bit before allowing auto-recenter
                mapMoveTimeout = setTimeout(() => {
                    isUserMovingMap = false;
                }, 3000); // 3 second delay after user stops moving
            });
            
            // Update navigation camera periodically
            window.navUpdateInterval = setInterval(() => {
                if (!isNavigating || !window.navigationCamera || isUserMovingMap) {
                    return; // Don't auto-recenter if user is moving map
                }
                
                const camera = window.navigationCamera;
                const userPos = getCurrentUserPosition();
                
                if (!userPos) return;
                
                const userLatLng = L.latLng(userPos[0], userPos[1]);
                
                // Find closest point on route
                let closestIndex = 0;
                let minDistance = Infinity;
                
                const searchStart = Math.max(0, camera.currentIndex - 20);
                const searchEnd = Math.min(camera.currentIndex + 50, camera.routePoints.length);
                
                for (let i = searchStart; i < searchEnd; i++) {
                    const distance = userLatLng.distanceTo(camera.routePoints[i]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                // Only update if user has moved significantly
                if (minDistance > 50 && Math.abs(closestIndex - camera.currentIndex) > 5) {
                    camera.currentIndex = closestIndex;
                    
                    // Look ahead for direction
                    const lookAhead = Math.min(closestIndex + 15, camera.routePoints.length - 1);
                    
                    // Smooth camera movement (only pan, don't zoom)
                    if (lookAhead > closestIndex) {
                        const targetPoint = camera.routePoints[closestIndex];
                        const currentCenter = map.getCenter();
                        const distanceToCenter = targetPoint.distanceTo(currentCenter);
                        
                        // Only move camera if user is far from center
                        if (distanceToCenter > 500) { // 500 meters
                            map.panTo(targetPoint, {
                                animate: true,
                                duration: 1,
                                easeLinearity: 0.25,
                                noMoveStart: true
                            });
                        }
                        
                        // Update bearing
                        camera.bearing = calculateBearing(
                            camera.routePoints[closestIndex],
                            camera.routePoints[lookAhead]
                        );
                    }
                }
                
                // Update route highlighting based on progress
                updateRouteHighlighting(camera.currentIndex, camera.routePoints.length);
                
            }, 2000); // Update every 2 seconds (slower to be less intrusive)
        }

        function updateRouteHighlighting(currentIndex, totalPoints) {
            if (!currentNavRoute || !currentNavRoute.geometry) return;
            
            const progress = currentIndex / totalPoints;
            
            // Update the route line to show progress
            routeLayer.clearLayers();
            
            // Draw completed portion in different color
            drawRouteProgress(currentNavRoute.geometry, progress);
        }

        function drawRouteProgress(geometry, progress) {
            const coords = geometry.coordinates;
            const splitIndex = Math.floor(coords.length * progress);
            
            // Completed portion
            if (splitIndex > 1) {
                const completedCoords = coords.slice(0, splitIndex);
                const completedGeoJSON = {
                    type: "LineString",
                    coordinates: completedCoords
                };
                
                L.geoJSON(completedGeoJSON, {
                    style: {
                        color: '#10b981', // Green for completed
                        weight: 6,
                        opacity: 0.9,
                        lineCap: 'round',
                        lineJoin: 'round'
                    }
                }).addTo(routeLayer);
            }
            
            // Remaining portion
            if (splitIndex < coords.length - 1) {
                const remainingCoords = coords.slice(splitIndex);
                const remainingGeoJSON = {
                    type: "LineString",
                    coordinates: remainingCoords
                };
                
                L.geoJSON(remainingGeoJSON, {
                    style: {
                        color: '#3b82f6', // Blue for remaining
                        weight: 6,
                        opacity: 0.7,
                        lineCap: 'round',
                        lineJoin: 'round',
                        dashArray: '10, 5' // Dashed for remaining
                    }
                }).addTo(routeLayer);
            }
            
            // Re-add arrows on remaining portion
            addDirectionArrows({
                type: "LineString",
                coordinates: coords.slice(splitIndex)
            });
            
            // Add user position marker
            addUserPositionMarker();
        }

        function addUserPositionMarker() {
            // Remove existing user nav marker
            if (window.userNavMarker) {
                map.removeLayer(window.userNavMarker);
            }
            
            const userPos = getCurrentUserPosition();
            if (!userPos) return;
            
            // Create navigation-style user marker
            const userIcon = L.divIcon({
                className: 'nav-user-marker',
                html: `
                    <div style="
                        position: relative;
                        width: 32px;
                        height: 32px;
                    ">
                        <div style="
                            position: absolute;
                            width: 24px;
                            height: 24px;
                            background: #3b82f6;
                            border-radius: 50%;
                            border: 3px solid white;
                            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
                            top: 0;
                            left: 0;
                        "></div>
                        <div style="
                            position: absolute;
                            width: 0;
                            height: 0;
                            border-left: 6px solid transparent;
                            border-right: 6px solid transparent;
                            border-top: 12px solid #3b82f6;
                            top: 22px;
                            left: 10px;
                            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
                        "></div>
                    </div>
                `,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
            
            window.userNavMarker = L.marker(userPos, {
                icon: userIcon,
                zIndexOffset: 2000
            }).addTo(map);
        }

        function getCurrentUserPosition() {
            if (customStartMode === 'current') {
                return userPos;
            } else if (customStartPos) {
                return customStartPos;
            }
            return userPos;
        }
        
        function transformSidebarToDirections(route) {
            const sidebar = document.getElementById('info-sidebar');
            sidebar.classList.add('active');
            
            const title = document.getElementById('side-title');
            title.innerText = "Turn-by-Turn Directions";
            
            const content = document.getElementById('sidebar-content');
            content.innerHTML = `
                <div class="space-y-1">
                    <div class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest mb-4">STEP-BY-STEP DIRECTIONS</div>
                    <div id="directions-list" class="space-y-2"></div>
                </div>
            `;
            
            generateDirectionsListUI(route);
        }
        
        function generateDirectionsListUI(route) {
            const container = document.getElementById('directions-list');
            container.innerHTML = '';
            
            if (!route.steps || route.steps.length === 0) {
                container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">No directions available</div>';
                return;
            }
            
            let cumulativeDistance = 0;
            
            route.steps.forEach((step, index) => {
                const instruction = step.maneuver.instruction;
                const distance = step.distance;
                const duration = step.duration || 0;
                const isActive = index === currentStepIndex;
                const isCompleted = index < currentStepIndex;
                
                cumulativeDistance += distance;
                
                const stepDiv = document.createElement('div');
                stepDiv.className = `direction-item flex items-start gap-3 ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}`;
                stepDiv.dataset.stepIndex = index;
                
                stepDiv.innerHTML = `
                    <div class="step-number ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}">
                        ${index + 1}
                    </div>
                    <div class="step-content">
                        <div class="step-instruction">${instruction}</div>
                        <div class="step-details">${distance < 1000 ? Math.round(distance) + ' m' : (distance/1000).toFixed(1) + ' km'} â¢ ${formatTime(duration)}</div>
                    </div>
                `;
                
                container.appendChild(stepDiv);
            });
        }
        
        async function checkFerryRouteFree(start, end) {
            const distance = map.distance(start, end);
            
            // Only check for ferry on water crossings
            if (distance < 10000 || distance > 500000) return { hasFerry: false }; // 10km to 500km
            
            // Use OpenStreetMap Nominatim to check if points are separated by water
            try {
                // Get water/land data from OpenStreetMap
                const [startWater, endWater] = await Promise.all([
                    isPointOverWater(start),
                    isPointOverWater(end)
                ]);
                
                if (startWater && endWater) {
                    // Both points in water - could be ferry route
                    const ferryTime = (distance / 40000) * 3600; // 40 km/h ferry speed
                    
                    return {
                        hasFerry: true,
                        duration: ferryTime + 1800, // +30 min boarding
                        distance: distance,
                        description: "Possible ferry route",
                        details: "Check local ferry schedules"
                    };
                }
                
            } catch (error) {
                console.error("Ferry check failed:", error);
            }
            
            return { hasFerry: false };
        }

        async function isPointOverWater(coords) {
            try {
                // Use OpenStreetMap's water/land data via Overpass API
                const [lat, lng] = coords;
                const query = `
                    [out:json][timeout:5];
                    (
                        way["natural"="water"](around:1000, ${lat}, ${lng});
                        relation["natural"="water"](around:1000, ${lat}, ${lng});
                    );
                    out body;
                `;
                
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`);
                const data = await response.json();
                
                return data.elements && data.elements.length > 0;
                
            } catch (error) {
                return false;
            }
        }

        function checkNavigationProgress(position) {
            if (!isNavigating || !currentNavRoute || !currentNavRoute.steps) return;
            
            const currentPos = [position.coords.latitude, position.coords.longitude];
            if (!currentPos) return;
            
            const currentStep = currentNavRoute.steps[currentStepIndex];
            if (!currentStep) return;
            
            // Simulate progress based on time (manual step advancement removed)
            const timeSinceStart = (new Date() - routeStartTime) / 1000;
            const progressPercent = Math.min(95, (timeSinceStart / (currentStep.duration || 30)) * 100);
            
            document.getElementById('step-progress').style.width = `${progressPercent}%`;
            
            // Update navigation HUD
            updateNavigationHUD();
        }
        
        function advanceToNextStep() {
            if (!currentNavRoute || !currentNavRoute.steps) return;
            
            if (currentStepIndex < currentNavRoute.steps.length - 1) {
                currentStepIndex++;
                updateNavigationDisplay();
                updateDirectionsListUI();
                updateNavigationHUD();
            } else {
                completeNavigation();
            }
        }
        
        function updateNavigationDisplay() {
            if (!currentNavRoute) return;
            
            const steps = currentNavRoute.steps || [];
            
            if (steps.length > 0 && currentStepIndex < steps.length) {
                const currentStep = steps[currentStepIndex];
                const nextStep = steps[currentStepIndex + 1];
                
                // Update display
                document.getElementById('nav-instruction').innerHTML = currentStep.maneuver.instruction;
                document.getElementById('nav-dist-next').innerText = 
                    currentStep.distance < 1000 ? `In ${Math.round(currentStep.distance)}m` : `In ${(currentStep.distance/1000).toFixed(1)}km`;
                
                // Reset progress bar
                document.getElementById('step-progress').style.width = '0%';
                
                // Update next turn
                if (nextStep) {
                    document.getElementById('nav-next-turn').innerText = 
                        nextStep.maneuver.instruction.split('.').slice(0, 2).join('.') + '.';
                } else {
                    document.getElementById('nav-next-turn').innerText = "Final destination ahead";
                }
                
                // Update ETA
                let remainingTime = 0;
                for (let i = currentStepIndex; i < steps.length; i++) {
                    remainingTime += steps[i].duration || 0;
                }
                
                const eta = getArrival(remainingTime);
                document.getElementById('nav-eta').innerText = eta;
                
                // Update remaining distance
                let remainingDistance = 0;
                for (let i = currentStepIndex; i < steps.length; i++) {
                    remainingDistance += steps[i].distance || 0;
                }
                
                document.getElementById('nav-remaining').innerText = 
                    remainingDistance < 1000 ? `${Math.round(remainingDistance)}m` : `${(remainingDistance/1000).toFixed(1)} km`;
                
                // Update icon
                updateNavIcon(currentStep);
            }
        }
        
        function updateNavigationHUD() {
            if (!currentNavRoute || !isNavigating) return;
            
            const steps = currentNavRoute.steps || [];
            
            // Calculate total remaining time and distance
            let remainingTime = 0;
            let remainingDistance = 0;
            
            for (let i = currentStepIndex; i < steps.length; i++) {
                remainingTime += steps[i].duration || 0;
                remainingDistance += steps[i].distance || 0;
            }
            
            // Update bottom left HUD
            const eta = getArrival(remainingTime);
            document.getElementById('hud-eta').innerText = eta;
            document.getElementById('hud-remaining').innerText = 
                remainingDistance < 1000 ? `${Math.round(remainingDistance)}m` : `${(remainingDistance/1000).toFixed(1)} km`;
        }
        
        function updateDirectionsListUI() {
            const directionItems = document.querySelectorAll('.direction-item');
            const stepNumbers = document.querySelectorAll('.step-number');
            
            directionItems.forEach((item, index) => {
                item.classList.remove('active', 'completed');
                stepNumbers[index].classList.remove('active', 'completed');
                
                if (index === currentStepIndex) {
                    item.classList.add('active');
                    stepNumbers[index].classList.add('active');
                } else if (index < currentStepIndex) {
                    item.classList.add('completed');
                    stepNumbers[index].classList.add('completed');
                }
            });
        }
        
        function completeNavigation() {
            document.getElementById('nav-instruction').innerText = "You have arrived at your destination";
            document.getElementById('nav-dist-next').innerText = "Arrived";
            document.getElementById('nav-next-turn').innerText = "Destination reached";
            document.getElementById('step-progress').style.width = '100%';
            document.getElementById('nav-eta').innerText = "Now";
            document.getElementById('nav-remaining').innerText = "0 m";
            
            // Update HUD for arrival
            document.getElementById('hud-eta').innerText = "Arrived";
            document.getElementById('hud-remaining').innerText = "0 m";
            
            if (gpsWatchInterval) {
                clearInterval(gpsWatchInterval);
                gpsWatchInterval = null;
            }
        }
        
        function updateNavIcon(step) {
            const icon = document.getElementById('nav-step-icon');
            const maneuver = step.maneuver.type || '';
            
            if (maneuver.includes('arrive')) {
                icon.setAttribute('icon', 'lucide:flag');
            } else if (maneuver.includes('depart')) {
                icon.setAttribute('icon', 'lucide:map-pin');
            } else if (maneuver.includes('left')) {
                icon.setAttribute('icon', 'lucide:corner-up-left');
            } else if (maneuver.includes('right')) {
                icon.setAttribute('icon', 'lucide:corner-up-right');
            } else if (maneuver.includes('roundabout')) {
                icon.setAttribute('icon', 'lucide:repeat');
            } else if (maneuver.includes('fork')) {
                icon.setAttribute('icon', 'lucide:git-fork');
            } else {
                icon.setAttribute('icon', 'lucide:navigation');
            }
        }
        
        function getRouteBounds(geometry) {
            const coords = geometry.coordinates;
            const bounds = [];
            
            for (const coord of coords) {
                bounds.push([coord[1], coord[0]]);
            }
            
            return bounds;
        }
        
        // --- ENHANCED SEARCH WITH FILTERS ---
        async function performSearch(query) {
            if (!query || query.trim().length < 2) {
                showRecentSearches();
                return;
            }
            
            saveToRecentSearches(query);
            
            document.getElementById('search-spinner').classList.remove('hidden');
            document.getElementById('filters').classList.remove('hidden');
            
            try {
                // INCREASED SEARCH RESULTS FROM 15 TO 25
                const response = await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=25`);
                const data = await response.json();
                
                searchResults = data.features || [];
                applyFilter(activeFilter);
            } catch (error) {
                console.error("Search failed:", error);
                searchResults = [];
                displaySearchResults([]);
            } finally {
                document.getElementById('search-spinner').classList.add('hidden');
            }
        }
        
        function saveToRecentSearches(query) {
            const recent = {
                query: query,
                timestamp: new Date().toISOString(),
                timeText: 'Just now'
            };
            
            recentSearches = recentSearches.filter(item => item.query !== query);
            recentSearches.unshift(recent);
            recentSearches = recentSearches.slice(0, 10);
            updateRecentTimes();
            localStorage.setItem('strikeRecentSearches', JSON.stringify(recentSearches));
        }
        
        function updateRecentTimes() {
            const now = new Date();
            recentSearches.forEach(item => {
                const itemTime = new Date(item.timestamp);
                const diffMinutes = Math.floor((now - itemTime) / (1000 * 60));
                
                if (diffMinutes < 1) item.timeText = 'Just now';
                else if (diffMinutes < 60) item.timeText = `${diffMinutes}m ago`;
                else if (diffMinutes < 1440) item.timeText = `${Math.floor(diffMinutes/60)}h ago`;
                else item.timeText = `${Math.floor(diffMinutes/1440)}d ago`;
            });
        }
        
        function showRecentSearches() {
            updateRecentTimes();
            const container = document.getElementById('results');
            const filters = document.getElementById('filters');
            
            if (recentSearches.length === 0) {
                // Still show filters even with no recent searches
                filters.classList.add('show');
                filters.classList.remove('hidden');
                
                container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">No recent searches</div>';
                container.classList.add('show');
                container.classList.remove('hidden');
                return;
            }
            
            filters.classList.remove('hidden');
            
            let html = `
                <div class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest mb-2">Recent Searches</div>
            `;
            
            recentSearches.forEach((recent) => {
                html += `
                    <div class="recent-item" data-query="${recent.query}">
                        <div class="flex justify-between items-center">
                            <div class="text-[11px] font-semibold text-white">${recent.query}</div>
                            <div class="recent-time">${recent.timeText}</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            container.classList.remove('hidden');
            
            document.querySelectorAll('.recent-item').forEach(item => {
                item.addEventListener('click', () => {
                    const query = item.dataset.query;
                    document.getElementById('search-input').value = query;
                    performSearch(query);
                });
            });
        }
        
        function applyFilter(filter) {
            activeFilter = filter;
            
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.filter === filter) {
                    btn.classList.add('active');
                }
            });
            
            let filteredResults = searchResults;
            
            if (filter !== 'all' && filter !== 'nearby') {
                filteredResults = searchResults.filter(result => {
                    const props = result.properties;
                    const name = props.name?.toLowerCase() || '';
                    
                    switch(filter) {
                        case 'hotels':
                            return name.includes('hotel') || name.includes('inn') || name.includes('motel');
                        case 'parks':
                            return name.includes('park') || name.includes('garden');
                        case 'restaurants':
                            return name.includes('restaurant') || name.includes('cafe') || name.includes('diner');
                        case 'gas':
                            return name.includes('gas') || name.includes('fuel') || name.includes('station');
                        default:
                            return true;
                    }
                });
            }
            
            displaySearchResults(filteredResults);
        }

        function generateRealNavigationInstruction(step, index, allSteps) {
            if (!step.maneuver) return "Continue";
            
            const distance = step.distance;
            const streetName = step.name || getStreetName(step);
            const maneuverType = step.maneuver.type;
            const modifier = step.maneuver.modifier || '';
            
            // Google-style distance formatting
            let distanceText = "";
            if (distance < 20) {
                distanceText = "";
            } else if (distance < 100) {
                distanceText = " soon";
            } else if (distance < 1000) {
                const rounded = Math.round(distance / 50) * 50;
                distanceText = ` in ${rounded}m`;
            } else {
                distanceText = ` in ${(distance / 1000).toFixed(1)} km`;
            }
            
            // Google/Apple style instructions
            switch(maneuverType) {
                case 'depart':
                    if (streetName) {
                        return `Start on ${streetName}`;
                    }
                    return "Head toward destination";
                    
                case 'turn':
                    if (modifier === 'left') {
                        if (distanceText) {
                            return `${distanceText}, turn left${streetName ? ' onto ' + streetName : ''}`;
                        }
                        return `Turn left${streetName ? ' onto ' + streetName : ''}`;
                    } else if (modifier === 'right') {
                        if (distanceText) {
                            return `${distanceText}, turn right${streetName ? ' onto ' + streetName : ''}`;
                        }
                        return `Turn right${streetName ? ' onto ' + streetName : ''}`;
                    } else if (modifier === 'sharp left') {
                        return `${distanceText}, sharp left${streetName ? ' onto ' + streetName : ''}`;
                    } else if (modifier === 'sharp right') {
                        return `${distanceText}, sharp right${streetName ? ' onto ' + streetName : ''}`;
                    } else if (modifier === 'slight left') {
                        return `${distanceText}, keep left${streetName ? ' onto ' + streetName : ''}`;
                    } else if (modifier === 'slight right') {
                        return `${distanceText}, keep right${streetName ? ' onto ' + streetName : ''}`;
                    }
                    return `${distanceText}, turn${streetName ? ' onto ' + streetName : ''}`;
                    
                case 'continue':
                    if (streetName) {
                        return `${distanceText}, continue on ${streetName}`;
                    }
                    return `${distanceText}, continue straight`;
                    
                case 'arrive':
                    if (index === allSteps.length - 1) {
                        return "You have arrived at your destination";
                    }
                    return `Arrive at waypoint`;
                    
                case 'roundabout':
                    const exitNum = step.maneuver.exit || 1;
                    let exitText = '';
                    if (exitNum === 1) exitText = '1st exit';
                    else if (exitNum === 2) exitText = '2nd exit';
                    else if (exitNum === 3) exitText = '3rd exit';
                    else exitText = `${exitNum}th exit`;
                    
                    if (distanceText) {
                        return `${distanceText}, take the ${exitText}${streetName ? ' onto ' + streetName : ''}`;
                    }
                    return `Take the ${exitText}${streetName ? ' onto ' + streetName : ''}`;
                    
                case 'merge':
                    return `${distanceText}, merge${streetName ? ' onto ' + streetName : ''}`;
                    
                case 'fork':
                    if (modifier === 'left') {
                        return `${distanceText}, keep left at the fork${streetName ? ' onto ' + streetName : ''}`;
                    } else if (modifier === 'right') {
                        return `${distanceText}, keep right at the fork${streetName ? ' onto ' + streetName : ''}`;
                    }
                    return `${distanceText}, at the fork, continue${streetName ? ' onto ' + streetName : ''}`;
                    
                case 'off ramp':
                    return `${distanceText}, take the exit${streetName ? ' onto ' + streetName : ''}`;
                    
                case 'on ramp':
                    return `${distanceText}, take the ramp${streetName ? ' onto ' + streetName : ''}`;
                    
                case 'end of road':
                    if (modifier === 'left') {
                        return `${distanceText}, at end of road, turn left${streetName ? ' onto ' + streetName : ''}`;
                    } else if (modifier === 'right') {
                        return `${distanceText}, at end of road, turn right${streetName ? ' onto ' + streetName : ''}`;
                    }
                    return `${distanceText}, at end of road, continue${streetName ? ' onto ' + streetName : ''}`;
                    
                case 'new name':
                    if (streetName) {
                        return `${distanceText}, road becomes ${streetName}`;
                    }
                    return `${distanceText}, continue`;
                    
                case 'notification':
                    // Handle specific notifications
                    if (step.maneuver.notification_type === 'toll') {
                        return `${distanceText}, toll road ahead`;
                    }
                    if (step.maneuver.notification_type === 'ferry') {
                        return `${distanceText}, take ferry`;
                    }
                    return streetName ? `${distanceText}, follow ${streetName}` : `${distanceText}, continue`;
                    
                case 'exit roundabout':
                    return `${distanceText}, exit the roundabout${streetName ? ' onto ' + streetName : ''}`;
                    
                default:
                    if (streetName) {
                        return `${distanceText}, follow ${streetName}`;
                    }
                    return `${distanceText}, continue`;
            }
        }
        
        function displaySearchResults(results) {
            const container = document.getElementById('results');
            container.innerHTML = '';
            
            if (results.length === 0) {
                container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">No results found</div>';
                container.classList.remove('hidden');
                return;
            }
            
            results.forEach((result) => {
                const div = document.createElement('div');
                div.className = 'search-result';
                
                const props = result.properties;
                const name = props.name || props.street || props.city || "Unnamed Location";
                const details = [props.housenumber, props.street, props.city, props.country]
                    .filter(Boolean)
                    .join(', ');
                
                div.innerHTML = `
                    <div class="text-[11px] font-bold text-white mb-1">${name}</div>
                    <div class="text-[9px] text-neutral-400">${details || 'Coordinates'}</div>
                `;
                
                div.onclick = () => {
                    const [lng, lat] = result.geometry.coordinates;
                    map.flyTo([lat, lng], 15, { animate: true, duration: 1 });
                    triggerAnalysis(lat, lng);
                    hideSearchResults();
                    document.getElementById('search-input').value = name;
                };
                
                container.appendChild(div);
            });
            
            container.classList.remove('hidden');
        }
        
        function hideSearchResults() {
            document.getElementById('results').classList.add('hidden');
            document.getElementById('filters').classList.add('hidden');
        }

        // --- UTILITIES ---
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m`;
            } else {
                return '<1m';
            }
        }
        
        function getArrival(seconds) {
            const now = new Date();
            const arrival = new Date(now.getTime() + seconds * 1000);
            return arrival.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        function closeSidebar() { 
            document.getElementById('info-sidebar').classList.remove('active'); 
            routeLayer.clearLayers(); 
            currentRoute = null;
            currentNavRoute = null;
            
            if (isNavigating) {
                exitNavigation();
                isNavigating = false;
                
                if (gpsWatchInterval) {
                    clearInterval(gpsWatchInterval);
                    gpsWatchInterval = null;
                }
            }
            
            if (gpsWatchInterval) {
                clearInterval(gpsWatchInterval);
                gpsWatchInterval = null;
            }

            if (destinationMarker && map.hasLayer(destinationMarker)) {
                map.removeLayer(destinationMarker);
            }
            
            // Reset sidebar to default
            document.getElementById('sidebar-content').innerHTML = `
                <div class="space-y-6">
                    <div id="logistics-module">
                        <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block mb-4">Routes via Engine</span>
                        <div id="route-options" class="flex flex-col gap-2"></div>
                    </div>
                    <div class="space-y-2">
                        <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block">Address</span>
                        <p id="side-address" class="text-xs text-neutral-400 leading-relaxed">Select a location to view details</p>
                    </div>
                </div>
            `;
        }
        
        function recenterMap() {
            if (userPos) {
                map.flyTo(userPos, 14, { animate: true, duration: 1 });
                userMarker.setLatLng(userPos);
            }
        }

        function updateDestinationMarker(lat, lng, name = "Destination") {
            // Remove existing destination marker if present
            if (destinationMarker && map.hasLayer(destinationMarker)) {
                map.removeLayer(destinationMarker);
            }
            
            // Create new destination marker
            destinationMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'destination-marker',
                    html: '<div style="background: #ef4444; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(239,68,68,0.5); position: relative;"><div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 6px; height: 6px; background: white; border-radius: 50%;"></div></div>',
                    iconSize: [22, 22],
                    iconAnchor: [11, 11]
                }),
                zIndexOffset: 1000,
                title: name
            });
            
            // Add to map
            destinationMarker.addTo(map);
            
            // Add popup with location name
            if (name && name !== "Destination") {
                destinationMarker.bindPopup(`
                    <div class="text-xs font-bold text-white" style="margin-right: 15px;">${name}</div>
                    <div class="text-[10px] text-neutral-600">Destination</div>
                `);
            }
        }

        async function checkRealFerryRoute(start, end) {
            try {
                const [startLng, startLat] = [start[1], start[0]];
                const [endLng, endLat] = [end[1], end[0]];
                
                // Use Overpass API to find ferry routes in the area
                const bbox = [
                    Math.min(startLat, endLat) - 1,
                    Math.min(startLng, endLng) - 1,
                    Math.max(startLat, endLat) + 1,
                    Math.max(startLng, endLng) + 1
                ].join(',');
                
                const overpassQuery = `
                    [out:json][timeout:25];
                    (
                        // Find ferry routes (route=ferry relations)
                        relation["route"="ferry"](${bbox});
                        // Find ferry ways
                        way["route"="ferry"](${bbox});
                        // Find ferry terminals (amenity=ferry_terminal)
                        node["amenity"="ferry_terminal"](${bbox});
                    );
                    out body;
                    >;
                    out skel qt;
                `;
                
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(overpassQuery)}`);
                const data = await response.json();
                
                if (data.elements && data.elements.length > 0) {
                    // Process ferry data
                    const ferryRoutes = data.elements.filter(el => 
                        el.type === 'relation' && el.tags && el.tags.route === 'ferry'
                    );
                    
                    const ferryTerminals = data.elements.filter(el => 
                        el.type === 'node' && el.tags && el.tags.amenity === 'ferry_terminal'
                    );
                    
                    if (ferryRoutes.length > 0 || ferryTerminals.length > 0) {
                        // Calculate if points are near ferry terminals
                        const startNearTerminal = isNearFerryTerminal(start, ferryTerminals);
                        const endNearTerminal = isNearFerryTerminal(end, ferryTerminals);
                        
                        if (startNearTerminal && endNearTerminal) {
                            // Estimate ferry time (average 30 knots â 55 km/h)
                            const distance = map.distance(start, end);
                            const ferryTime = (distance / 55000) * 3600; // seconds
                            
                            return {
                                hasFerry: true,
                                duration: ferryTime + 1800, // +30 min for boarding
                                distance: distance,
                                description: "Ferry route available",
                                terminals: {
                                    start: startNearTerminal.name || "Ferry terminal",
                                    end: endNearTerminal.name || "Ferry terminal"
                                }
                            };
                        }
                    }
                }
                
                return { hasFerry: false };
            } catch (error) {
                console.error("Ferry route check failed:", error);
                return { hasFerry: false };
            }
        }

        function isNearFerryTerminal(point, terminals) {
            const [lat, lng] = point;
            
            for (const terminal of terminals) {
                const terminalLat = terminal.lat;
                const terminalLng = terminal.lon;
                const distance = map.distance([lat, lng], [terminalLat, terminalLng]);
                
                if (distance < 5000) { // Within 5km
                    return {
                        name: terminal.tags.name || "Ferry Terminal",
                        lat: terminalLat,
                        lng: terminalLng
                    };
                }
            }
            return null;
        }
        
        function exitNavigation() {
            isNavigating = false;
            document.body.classList.remove('navigating');
            document.getElementById('standard-ui').style.display = 'flex';
            document.getElementById('active-nav-hud').style.display = 'none';
            
            // Clear navigation intervals
            if (window.navUpdateInterval) {
                clearInterval(window.navUpdateInterval);
                window.navUpdateInterval = null;
            }
            
            // Clear map move listeners
            map.off('movestart');
            map.off('moveend');
            
            // Clear navigation camera
            window.navigationCamera = null;
            
            // Clear route arrows
            if (window.routeArrows) {
                window.routeArrows.clearLayers();
                window.routeArrows = null;
            }
            
            // Clear user nav marker
            if (window.userNavMarker) {
                map.removeLayer(window.userNavMarker);
                window.userNavMarker = null;
            }
            
            // Reset route layer
            routeLayer.clearLayers();
            
            // Reset navigation state
            currentNavRoute = null;
            currentStepIndex = 0;
            
            // Reset map cursor
            map.getContainer().style.cursor = '';
            
            // Reset sidebar
            closeSidebar();
        }

        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {
            // Search input
            const searchInput = document.getElementById('search-input');
            let searchTimeout;
            
            searchInput.addEventListener('focus', () => {
                showRecentSearches();
            });
            
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                if (!e.target.value.trim()) {
                    showRecentSearches();
                    return;
                }
                searchTimeout = setTimeout(() => {
                    performSearch(e.target.value);
                }, 300);
            });
            
            // Filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const filter = e.target.dataset.filter;
                    applyFilter(filter);
                    if (searchInput.value.trim()) {
                        performSearch(searchInput.value);
                    }
                });
            });
            
            // Locate button
            document.getElementById('locate-btn').addEventListener('click', recenterMap);
            
            // Satellite toggle
            document.getElementById('sat-toggle').addEventListener('click', () => {
                if (map.hasLayer(satLayer)) {
                    map.removeLayer(satLayer);
                } else {
                    satLayer.addTo(map);
                }
            });
            
            // Zoom buttons
            document.getElementById('zoom-in').addEventListener('click', () => {
                map.zoomIn();
            });
            
            document.getElementById('zoom-out').addEventListener('click', () => {
                map.zoomOut();
            });
            
            document.getElementById('exit-nav-btn').addEventListener('click', exitNavigation);
            
            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                const searchContainer = document.querySelector('.strike-glass.p-2');
                const results = document.getElementById('results');
                
                if (searchContainer && results && !searchContainer.contains(e.target) && 
                    e.target !== searchInput) {
                    hideSearchResults();
                }
            });
        });
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
            }
            if (gpsWatchInterval) {
                clearInterval(gpsWatchInterval);
            }
        });
    </script>
</body>
</html>
