<!-- Compiled in Cursor | Last build update: 2/7/2026  5:38:56 PM | Version No. 5 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strike Maps</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@500;600;700;800&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        :root {
            --bg: #000000;
            --glass-surface: rgba(10, 10, 10, 0.85);
            --glass-border: rgba(255, 255, 255, 0.08);
            --font-main: 'Manrope', sans-serif;
            --ease-pro: cubic-bezier(0.2, 0, 0, 1);
        }

        body, html { margin: 0; padding: 0; background: var(--bg); color: #fff; font-family: var(--font-main); height: 100vh; width: 100vw; overflow: hidden; }

        #map { height: 100%; width: 100%; z-index: 1; background: #050505; transition: opacity 1s ease; }
        .dark-layer { filter: invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%); }
        
        .strike-glass { background: var(--glass-surface); backdrop-filter: blur(30px); border: 1px solid var(--glass-border); box-shadow: 0 24px 60px rgba(0,0,0,0.9); border-radius: 16px; }
        .strike-input { background: rgba(255,255,255,0.03); border: 1px solid var(--glass-border); color: white; transition: all 0.3s var(--ease-pro); }

        #info-sidebar { position: absolute; right: 24px; top: 24px; bottom: 24px; width: 380px; z-index: 2000; transform: translateX(calc(100% + 50px)); transition: transform 0.8s var(--ease-pro); display: flex; flex-direction: column; }
        #info-sidebar.active { transform: translateX(0); }

        .route-card { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); padding: 12px; border-radius: 12px; transition: all 0.2s; cursor: pointer; }
        .route-card.active { border-color: #ffffff; background: rgba(255, 255, 255, 0.05); }

        /* ACTIVE NAV HUD */
        #active-nav-hud { display: none; }
        
        #loader { position: fixed; inset: 0; z-index: 9999; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s; }
        .loading-bar { width: 120px; height: 2px; background: #111; margin-top: 15px; position: relative; overflow: hidden; }
        .loading-fill { position: absolute; left: 0; top: 0; height: 100%; background: #fff; width: 0%; animation: load 2s forwards; }
        @keyframes load { to { width: 100%; } }

        .ui-animate { opacity: 0; transform: translateY(15px); transition: all 0.8s var(--ease-pro); }
        .ui-ready .ui-animate { opacity: 1; transform: translateY(0); }
        
        .gps-ring { border: 2px solid #fff; border-radius: 50%; height: 18px; width: 18px; box-shadow: 0 0 15px rgba(255,255,255,0.6); position: relative; }
        
        /* Search results and filters */
        #results { max-height: 250px; overflow-y: auto; }
        #results::-webkit-scrollbar { width: 4px; }
        #results::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 2px; }
        #results::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        .search-result { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; transition: all 0.2s; }
        .search-result:hover { background: rgba(255,255,255,0.05); }
        .search-result:last-child { border-bottom: none; }
        
        .filter-btn { padding: 6px 10px; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; font-size: 10px; font-weight: 600; background: rgba(255,255,255,0.03); color: rgba(255,255,255,0.7); transition: all 0.2s; }
        .filter-btn.active { background: rgba(255,255,255,0.1); color: white; border-color: rgba(255,255,255,0.3); }
        
        /* Navigation instructions */
        .nav-instruction-text { font-size: 13px; line-height: 1.4; }
        
        /* Exit navigation button */
        #exit-nav-btn { background: rgba(239, 68, 68, 0.25); border: 1px solid rgba(239, 68, 68, 0.5); color: #ff6b6b; }
        #exit-nav-btn:hover { background: #ef4444; color: white; border-color: #ef4444; }
        
        /* Path styling */
        .aviation-path { stroke-dasharray: 10, 10; }
        
        /* Type badges */
        .type-badge { 
            font-size: 8px; 
            font-weight: 700; 
            padding: 2px 5px; 
            border-radius: 4px; 
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .type-city { background: rgba(59, 130, 246, 0.2); color: #93c5fd; }
        .type-street { background: rgba(139, 92, 246, 0.2); color: #c4b5fd; }
        .type-building { background: rgba(239, 68, 68, 0.2); color: #fca5a5; }
        .type-landmark { background: rgba(245, 158, 11, 0.2); color: #fcd34d; }
        .type-default { background: rgba(255, 255, 255, 0.1); color: rgba(255, 255, 255, 0.7); }
        
        /* Directions list */
        .direction-step { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .direction-step.active { background: rgba(59, 130, 246, 0.1); border-left: 3px solid #3b82f6; }
        .direction-step.completed { opacity: 0.6; }
        .step-distance { font-size: 10px; color: #6b7280; font-weight: 600; }
        
        /* Traffic indicators */
        .traffic-indicator { 
            display: inline-block; 
            width: 6px; 
            height: 6px; 
            border-radius: 50%; 
            margin-right: 4px;
        }
        .traffic-high { background: #ef4444; }
        .traffic-medium { background: #f59e0b; }
        .traffic-low { background: #10b981; }
        
        /* Recents list */
        .recent-item { padding: 8px 12px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; }
        .recent-item:hover { background: rgba(255,255,255,0.05); }
        .recent-time { font-size: 9px; color: #6b7280; }
        
        /* Progress bar */
        .progress-bar { height: 3px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #10b981, #3b82f6); transition: width 0.3s; }
    </style>
</head>
<body class="bg-black">

    <div id="loader">
        <svg viewBox="0 0 76 65" fill="white" class="w-12 h-12 mb-4 animate-pulse"><path d="M37.5274 0L75.0548 65H0L37.5274 0Z"></path></svg>
        <div class="text-[9px] font-bold text-neutral-500 uppercase tracking-[0.5em]">Requestin location...</div>
        <div class="loading-bar"><div class="loading-fill"></div></div>
    </div>

    <div id="map"></div>

    <div id="standard-ui" class="absolute top-6 left-6 z-[1000] w-[340px] flex flex-col gap-3">
        <div class="strike-glass p-2 ui-animate">
            <div class="relative group">
                <iconify-icon icon="lucide:search" class="absolute left-3 top-2.5 text-neutral-500"></iconify-icon>
                <input type="text" id="search-input" placeholder="Search destination..." class="w-full h-10 pl-10 pr-4 rounded-xl text-xs font-bold strike-input">
                <div id="search-spinner" class="hidden absolute right-3 top-3"><iconify-icon icon="lucide:loader-2" class="animate-spin text-white"></iconify-icon></div>
            </div>
            <div id="filters" class="hidden mt-2 flex gap-1 flex-wrap">
                <button class="filter-btn active" data-filter="all">All</button>
                <button class="filter-btn" data-filter="nearby">Near Me</button>
                <button class="filter-btn" data-filter="hotels">Hotels</button>
                <button class="filter-btn" data-filter="parks">Parks</button>
                <button class="filter-btn" data-filter="restaurants">Restaurants</button>
                <button class="filter-btn" data-filter="gas">Gas Stations</button>
            </div>
            <div id="results" class="hidden mt-2 flex flex-col"></div>
        </div>
        <div class="strike-glass px-4 py-3 flex items-center justify-between ui-animate">
            <div class="flex flex-col">
                <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-tight">Signal State</span>
                <span id="status-text" class="text-[11px] font-bold text-white">Standby</span>
            </div>
            <button id="locate-btn" class="h-8 px-4 bg-white text-black rounded-lg text-[11px] font-extrabold flex items-center gap-2 hover:bg-neutral-100 transition-all">
                <iconify-icon icon="lucide:crosshair"></iconify-icon> Re-Center
            </button>
        </div>
    </div>

    <div id="active-nav-hud" class="absolute top-6 left-6 z-[2000] w-[340px] flex flex-col gap-3">
        <div class="strike-glass p-4 border-l-4 border-emerald-500">
            <div class="flex items-center gap-4">
                <div class="w-12 h-12 rounded-xl bg-white/10 flex items-center justify-center">
                    <iconify-icon id="nav-step-icon" icon="lucide:navigation" class="text-2xl text-emerald-400"></iconify-icon>
                </div>
                <div class="flex-1">
                    <span id="nav-dist-next" class="text-[10px] font-bold text-emerald-400 uppercase tracking-widest mb-1">In 200m</span>
                    <h3 id="nav-instruction" class="nav-instruction-text font-bold text-white leading-tight">Continue straight for 1.2 kilometers on Main Street</h3>
                    <div class="progress-bar mt-2">
                        <div id="step-progress" class="progress-fill" style="width: 30%"></div>
                    </div>
                </div>
            </div>
            <div class="mt-4 pt-4 border-t border-white/5">
                <div class="flex justify-between text-[11px]">
                    <div>
                        <div class="text-neutral-500 mb-1">Next Turn</div>
                        <div id="nav-next-turn" class="text-white font-semibold">Right onto Broadway</div>
                    </div>
                    <div>
                        <div class="text-neutral-500 mb-1">ETA</div>
                        <div id="nav-eta" class="text-emerald-400 font-bold">14:30</div>
                    </div>
                    <div>
                        <div class="text-neutral-500 mb-1">Remaining</div>
                        <div id="nav-remaining" class="text-white font-bold">4.2 km</div>
                    </div>
                </div>
            </div>
        </div>
        <button id="exit-nav-btn" class="w-full h-10 bg-red-500/25 border border-red-500/50 text-white rounded-xl text-[10px] font-black uppercase tracking-widest flex items-center justify-center gap-2 hover:bg-red-500 transition-all duration-200">
            <iconify-icon icon="lucide:x-circle"></iconify-icon> Exit Navigation
        </button>
    </div>

    <div id="info-sidebar" class="strike-glass">
        <div class="p-6 border-b border-white/5 flex items-center justify-between">
            <h2 id="side-title" class="text-xl font-bold text-white truncate pr-4">Location</h2>
            <button onclick="closeSidebar()" class="text-neutral-500 hover:text-white"><iconify-icon icon="lucide:x" class="text-xl"></iconify-icon></button>
        </div>
        <div id="sidebar-content" class="p-6 flex-1 overflow-y-auto space-y-6">
            <div id="logistics-module">
                <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block mb-4">Routes via Engine</span>
                <div id="route-options" class="flex flex-col gap-2"></div>
            </div>
            <div class="space-y-2">
                <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block">Address</span>
                <p id="side-address" class="text-xs text-neutral-400 leading-relaxed">Calculating coordinates...</p>
            </div>
        </div>
        <div class="p-6 bg-white/[0.02] border-t border-white/5 flex gap-2">
            <button id="start-nav-btn" class="hidden flex-1 h-12 bg-white text-black rounded-xl text-xs font-black flex items-center justify-center gap-3">
                <iconify-icon icon="lucide:navigation-2" class="text-lg"></iconify-icon> START NAVIGATION
            </button>
        </div>
    </div>

    <div class="absolute bottom-6 right-6 z-[1000] flex flex-col gap-3 ui-animate">
        <div class="strike-glass p-1 flex flex-col gap-1">
            <button id="sat-toggle" class="w-10 h-10 flex items-center justify-center rounded-xl text-neutral-400 hover:text-white transition-all"><iconify-icon icon="lucide:layers" class="text-lg"></iconify-icon></button>
        </div>
        <div class="strike-glass p-1 flex flex-col gap-1">
            <button id="zoom-in" class="w-10 h-10 flex items-center justify-center rounded-xl hover:bg-white/10 text-neutral-400 hover:text-white transition-all"><iconify-icon icon="lucide:plus"></iconify-icon></button>
            <button id="zoom-out" class="w-10 h-10 flex items-center justify-center rounded-xl hover:bg-white/10 text-neutral-400 hover:text-white transition-all"><iconify-icon icon="lucide:minus"></iconify-icon></button>
        </div>
    </div>

    <div class="absolute bottom-6 left-6 z-[1000] pointer-events-none flex flex-col gap-4 ui-animate">
        <div class="strike-glass px-4 py-3 flex gap-6 items-center pointer-events-auto">
            <div class="flex flex-col"><span class="text-[8px] font-bold text-neutral-500 uppercase">Pos</span><span id="hud-coords" class="text-[10px] font-mono text-white mt-1">0.0, 0.0</span></div>
            <div class="flex flex-col"><span class="text-[8px] font-bold text-neutral-500 uppercase">Acc</span><span id="hud-precision" class="text-[10px] font-mono text-white mt-1">-- m</span></div>
        </div>
        <div class="opacity-40 text-[10px] font-black uppercase tracking-widest text-white flex items-center gap-2">
            <svg width="12" height="12" viewBox="0 0 76 65" fill="white"><path d="M37.5274 0L75.0548 65H0L37.5274 0Z"></path></svg>
            Strike Maps [v4]
        </div>
    </div>

    <script>
        // Initialize variables
        let map = null;
        let darkBase = null;
        let satLayer = null;
        const userIcon = L.divIcon({ 
            className: 'empty', 
            html: '<div class="gps-ring"></div>', 
            iconSize: [20, 20], 
            iconAnchor: [10, 10] 
        });
        let userMarker = L.marker([0,0], {icon: userIcon});
        let routeLayer = L.layerGroup();
        let userPos = null;
        let selectedTarget = null;
        let currentRoute = null;
        let currentNavRoute = null;
        let currentStepIndex = 0;
        let searchResults = [];
        let activeFilter = 'all';
        let isNavigating = false;
        let recentSearches = JSON.parse(localStorage.getItem('strikeRecentSearches')) || [];
        let watchId = null;
        let totalRouteDistance = 0;
        let routeStartTime = null;
        let remainingDistance = 0;
        let gpsWatchInterval = null;
        
        // Map initialization function
        function initMap() {
            map = L.map('map', { 
                zoomControl: false, 
                attributionControl: false, 
                maxBounds: [[-85, -10000], [85, 10000]], 
                maxBoundsViscosity: 1.0, 
                worldCopyJump: true, 
                minZoom: 3 
            }).setView([0, 0], 2);
            
            darkBase = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                maxZoom: 19, 
                className: 'dark-layer' 
            }).addTo(map);
            
            satLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { 
                maxZoom: 19 
            });
            
            routeLayer.addTo(map);
        }
        
        // Setup map event listeners
        function setupMapEvents() {
            if (!map) return;
            
            map.on('click', (e) => {
                if (isNavigating) return; // Prevent map clicks during navigation
                triggerAnalysis(e.latlng.lat, e.latlng.lng);
                hideSearchResults();
            });
            
            map.on('mousemove', (e) => {
                document.getElementById('hud-coords').innerText = 
                    `${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`;
            });
            
            map.on('move', () => {
                hideSearchResults();
            });
        }
        
        // --- LOAD & GPS ---
        window.onload = () => {
            initMap();
            
            // Wait for loading animation to complete (2 seconds) before requesting location
            setTimeout(() => {
                // Try to get current position
                if (navigator.geolocation) {
                    document.getElementById('status-text').innerText = "Acquiring Signal";
                    
                    // Start watching position for continuous updates
                    watchId = navigator.geolocation.watchPosition(
                        (pos) => {
                            userPos = [pos.coords.latitude, pos.coords.longitude];
                            
                            if (!userMarker.getLatLng() || userMarker.getLatLng().distanceTo(userPos) > 10) {
                                userMarker.setLatLng(userPos);
                                if (!isNavigating) {
                                    map.panTo(userPos, {animate: true, duration: 1});
                                }
                            }
                            
                            document.getElementById('hud-precision').innerText = `${pos.coords.accuracy.toFixed(0)}m`;
                            document.getElementById('status-text').innerText = "Signal Locked";
                            
                            // Update coordinates display
                            document.getElementById('hud-coords').innerText = 
                                `${userPos[0].toFixed(4)}, ${userPos[1].toFixed(4)}`;
                            
                            // Check navigation progress if navigating
                            if (isNavigating && currentNavRoute) {
                                checkNavigationProgress(pos);
                            }
                            
                            // Hide loader on first location
                            if (document.getElementById('loader').style.display !== 'none') {
                                document.getElementById('loader').style.opacity = '0';
                                setTimeout(() => { 
                                    document.getElementById('loader').style.display = 'none'; 
                                    document.body.classList.add('ui-ready'); 
                                    setupMapEvents(); // Setup map events after UI is ready
                                }, 500);
                            }
                        },
                        (error) => { 
                            // Geolocation failed
                            userPos = [40.7128, -74.0060]; // Default to NYC
                            map.setView(userPos, 2);
                            userMarker.setLatLng(userPos).addTo(map);
                            document.getElementById('status-text').innerText = "GPS Unavailable";
                            
                            document.getElementById('loader').style.opacity = '0';
                            setTimeout(() => { 
                                document.getElementById('loader').style.display = 'none'; 
                                document.body.classList.add('ui-ready'); 
                                setupMapEvents(); // Setup map events after UI is ready
                            }, 500);
                        },
                        { 
                            enableHighAccuracy: true,
                            maximumAge: 1000,
                            timeout: 5000
                        }
                    );
                } else {
                    // Geolocation not supported
                    userPos = [40.7128, -74.0060];
                    map.setView(userPos, 2);
                    userMarker.setLatLng(userPos).addTo(map);
                    
                    document.getElementById('loader').style.opacity = '0';
                    setTimeout(() => { 
                        document.getElementById('loader').style.display = 'none'; 
                        document.body.classList.add('ui-ready'); 
                        setupMapEvents(); // Setup map events after UI is ready
                    }, 500);
                }
            }, 2000); // Wait for loading animation
        };
        
        // --- CORE LOGISTICS ---
        async function triggerAnalysis(lat, lng) {
            selectedTarget = [lat, lng];
            const sidebar = document.getElementById('info-sidebar');
            sidebar.classList.add('active');
            routeLayer.clearLayers();
            document.getElementById('start-nav-btn').classList.add('hidden');
            
            // Update sidebar title immediately
            document.getElementById('side-title').innerText = "Processing...";
            document.getElementById('side-address').innerText = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            
            try {
                const res = await fetch(`https://photon.komoot.io/reverse?lon=${lng}&lat=${lat}&limit=1`);
                const data = await res.json();
                
                if (data.features && data.features.length > 0) {
                    const p = data.features[0].properties || {};
                    document.getElementById('side-title').innerText = 
                        p.name || p.street || "Unnamed Location";
                    document.getElementById('side-address').innerText = 
                        [p.street, p.city, p.country, p.postcode].filter(Boolean).join(', ') || "Coordinates Verified";
                } else {
                    document.getElementById('side-title').innerText = "Location";
                    document.getElementById('side-address').innerText = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                }
            } catch (error) {
                console.error("Reverse geocoding failed:", error);
                document.getElementById('side-title').innerText = "Target Node";
                document.getElementById('side-address').innerText = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
            }
            
            if (userPos && !isNavigating) {
                calculateRoutes(userPos, [lat, lng]);
            }
        }
        
        async function calculateRoutes(start, end) {
            const container = document.getElementById('route-options');
            container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">Calculating routes...</div>';
            
            const distance = map.distance(start, end);
            const routes = [];
            
            // Calculate traffic level for driving routes
            const trafficLevel = calculateTrafficLevel(start, end);
            
            // 1. Plane Route if over 300km
            if (distance > 300000) {
                routes.push({
                    id: 'aviation',
                    icon: 'lucide:plane',
                    label: 'Air Corridor',
                    duration: distance / 800000 * 3600, // Approx 800 km/h
                    distance: distance,
                    geometry: createAviationPath(start, end),
                    steps: [
                        {
                            distance: distance,
                            maneuver: {
                                instruction: `Fly from current location to destination`,
                                type: 'depart'
                            }
                        }
                    ]
                });
            }
            
            // Calculate other routes
            const modes = [
                { id: 'driving', icon: 'lucide:car', label: 'Driving' },
                { id: 'cycling', icon: 'lucide:bike', label: 'Cycling' },
                { id: 'walking', icon: 'lucide:footprints', label: 'Walking' }
            ];
            
            for (const m of modes) {
                try {
                    const r = await fetch(`https://router.project-osrm.org/route/v1/${m.id}/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson&steps=true`)
                        .then(res => res.json());
                    
                    if (r.routes?.[0]) {
                        const route = {
                            id: m.id,
                            icon: m.icon,
                            label: m.label,
                            duration: r.routes[0].duration,
                            distance: r.routes[0].distance,
                            geometry: r.routes[0].geometry,
                            legs: r.routes[0].legs,
                            steps: processOSRMSteps(r.routes[0].legs?.[0]?.steps || []),
                            fullRouteData: r.routes[0]
                        };
                        
                        // Add traffic info for driving
                        if (m.id === 'driving') {
                            route.traffic = trafficLevel;
                            route.originalDuration = r.routes[0].duration;
                            // Adjust duration based on traffic
                            if (trafficLevel === 'high') {
                                route.duration = route.duration * 1.4;
                            } else if (trafficLevel === 'medium') {
                                route.duration = route.duration * 1.2;
                            }
                        }
                        
                        routes.push(route);
                    }
                } catch(e) {
                    console.error(`Route calculation failed for ${m.id}:`, e);
                }
            }
            
            // Display routes
            container.innerHTML = '';
            if (routes.length === 0) {
                container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">No routes available</div>';
                return;
            }
            
            routes.forEach(route => {
                addRouteCard(route);
            });
        }
        
        function processOSRMSteps(osrmSteps) {
            return osrmSteps.map(step => ({
                distance: step.distance,
                duration: step.duration,
                geometry: step.geometry,
                maneuver: {
                    instruction: formatOSRMInstruction(step.maneuver),
                    type: step.maneuver.type,
                    modifier: step.maneuver.modifier,
                    location: step.maneuver.location
                },
                name: step.name || "",
                way_points: step.way_points
            }));
        }
        
        function formatOSRMInstruction(maneuver) {
            if (!maneuver) return "Continue on current route";
            
            const instruction = maneuver.instruction || "";
            
            // Clean up OSRM instructions to be more natural
            let cleanInstruction = instruction
                .replace(/Head /g, 'Continue ')
                .replace(/Go straight /g, 'Continue ')
                .replace(/ on<[^>]+>/g, ' on')
                .replace(/<[^>]+>/g, '') // Remove HTML tags
                .replace(/  +/g, ' '); // Remove extra spaces
            
            // Capitalize first letter
            cleanInstruction = cleanInstruction.charAt(0).toUpperCase() + cleanInstruction.slice(1);
            
            return cleanInstruction;
        }
        
        function calculateTrafficLevel(start, end) {
            // Simulate traffic calculation based on time of day and distance
            const now = new Date();
            const hour = now.getHours();
            const distance = map.distance(start, end);
            
            // High traffic during rush hours (8-10 AM, 4-7 PM) for short-medium distances
            if (distance < 50000 && ((hour >= 8 && hour <= 10) || (hour >= 16 && hour <= 19))) {
                return Math.random() > 0.5 ? 'high' : 'medium';
            }
            
            // Otherwise random distribution
            const rand = Math.random();
            if (rand > 0.7) return 'high';
            if (rand > 0.4) return 'medium';
            return 'low';
        }
        
        function createAviationPath(start, end) {
            return {
                type: "LineString",
                coordinates: [
                    [start[1], start[0]],
                    [end[1], end[0]]
                ]
            };
        }
        
        function addRouteCard(route) {
            const container = document.getElementById('route-options');
            const div = document.createElement('div');
            div.className = "route-card";
            div.dataset.routeId = route.id;
            
            const timeStr = formatTime(route.duration);
            const arrival = getArrival(route.duration);
            const distanceStr = (route.distance / 1000).toFixed(1) + ' km';
            
            // Add traffic indicator for driving
            let trafficIndicator = '';
            if (route.id === 'driving' && route.traffic) {
                const trafficClass = `traffic-${route.traffic}`;
                trafficIndicator = `<span class="traffic-indicator ${trafficClass}"></span>`;
            }
            
            div.innerHTML = `
                <div class="flex items-center gap-4">
                    <iconify-icon icon="${route.icon}" class="text-xl text-neutral-500"></iconify-icon>
                    <div class="flex-1">
                        <div class="flex justify-between items-center">
                            <div class="text-[10px] font-bold text-white">${trafficIndicator}${route.label}</div>
                            <div class="text-[9px] font-bold text-emerald-400">${distanceStr}</div>
                        </div>
                        <div class="text-[9px] text-neutral-400 uppercase">${timeStr} • Arr: ${arrival}</div>
                    </div>
                </div>`;
            
            div.onclick = () => {
                document.querySelectorAll('.route-card').forEach(c => c.classList.remove('active'));
                div.classList.add('active');
                currentRoute = route;
                renderPath(route);
            };
            container.appendChild(div);
        }
        
        function renderPath(route) {
            routeLayer.clearLayers();
            
            if (!route || !route.geometry) {
                console.error("No route geometry available");
                return;
            }
            
            // Set path color based on mode and traffic
            let color = '#10b981'; // Green - default
            let weight = 5;
            let dashArray = null;
            
            if (route.id === 'driving') {
                // Color based on traffic
                if (route.traffic === 'high') color = '#ef4444';
                else if (route.traffic === 'medium') color = '#f59e0b';
                else color = '#10b981';
            } else if (route.id === 'aviation') {
                color = '#ffffff';
                weight = 3;
                dashArray = '10, 10';
            } else if (route.id === 'cycling') {
                color = '#3b82f6'; // Blue
            } else if (route.id === 'walking') {
                color = '#8b5cf6'; // Purple
                weight = 3;
            }
            
            // Create GeoJSON feature
            const feature = {
                type: "Feature",
                geometry: route.geometry,
                properties: {}
            };
            
            L.geoJSON(feature, {
                style: { 
                    color: color, 
                    weight: weight, 
                    opacity: 0.8,
                    dashArray: dashArray
                }
            }).addTo(routeLayer);
            
            // Show start navigation button
            document.getElementById('start-nav-btn').classList.remove('hidden');
            document.getElementById('start-nav-btn').onclick = () => startActiveNav(route);
        }
        
        // --- REAL NAVIGATION WITH GPS ---
        function startActiveNav(route) {
            isNavigating = true;
            currentNavRoute = route;
            currentStepIndex = 0;
            routeStartTime = new Date();
            totalRouteDistance = route.distance;
            remainingDistance = totalRouteDistance;
            
            document.getElementById('standard-ui').style.display = 'none';
            document.getElementById('active-nav-hud').style.display = 'flex';
            
            // Transform sidebar to directions list
            transformSidebarToDirections(route);
            
            // Update navigation display
            updateNavigationDisplay();
            
            // Start GPS-based navigation monitoring
            startNavigationMonitoring();
            
            // Center map on user
            map.flyTo(userPos, 18, { animate: true, duration: 1.5 });
        }
        
        function transformSidebarToDirections(route) {
            const sidebar = document.getElementById('info-sidebar');
            sidebar.classList.add('active');
            
            const title = document.getElementById('side-title');
            title.innerText = "Navigation Steps";
            
            const content = document.getElementById('sidebar-content');
            content.innerHTML = `
                <div id="directions-list" class="space-y-1">
                    <div class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest mb-4">Step-by-step Directions</div>
                    ${generateDirectionsList(route)}
                </div>
            `;
        }
        
        function generateDirectionsList(route) {
            if (!route.steps || route.steps.length === 0) {
                return '<div class="text-xs text-neutral-500 p-4 text-center">No detailed directions available</div>';
            }
            
            let html = '';
            let cumulativeDistance = 0;
            
            route.steps.forEach((step, index) => {
                const instruction = step.maneuver.instruction || "Continue on current route";
                const distance = Math.round(step.distance);
                const duration = step.duration || 0;
                const isActive = index === currentStepIndex;
                const isCompleted = index < currentStepIndex;
                
                cumulativeDistance += distance;
                
                const classes = `direction-step ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}`;
                
                html += `
                    <div class="${classes}" data-step-index="${index}">
                        <div class="flex items-start gap-3">
                            <div class="w-6 h-6 rounded-full bg-white/5 flex items-center justify-center mt-0.5">
                                <span class="text-[10px] font-bold ${isActive ? 'text-emerald-400' : 'text-neutral-500'}">${index + 1}</span>
                            </div>
                            <div class="flex-1">
                                <div class="text-xs font-semibold text-white mb-1">${instruction}</div>
                                <div class="step-distance">${distance}m • ${formatTime(duration)}</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function startNavigationMonitoring() {
            // Clear any existing interval
            if (gpsWatchInterval) {
                clearInterval(gpsWatchInterval);
            }
            
            // Check navigation progress every 2 seconds
            gpsWatchInterval = setInterval(() => {
                if (isNavigating && currentNavRoute && userPos) {
                    checkNavigationProgressManually();
                }
            }, 2000);
        }
        
        function checkNavigationProgress(position) {
            if (!isNavigating || !currentNavRoute || !currentNavRoute.steps) return;
            
            const currentPos = position ? [position.coords.latitude, position.coords.longitude] : userPos;
            if (!currentPos) return;
            
            const currentStep = currentNavRoute.steps[currentStepIndex];
            if (!currentStep) return;
            
            // Calculate distance to the end of current step
            const stepEnd = currentStep.maneuver?.location || getStepEndCoordinate(currentStep);
            if (!stepEnd) return;
            
            const distanceToStepEnd = map.distance(currentPos, [stepEnd[1], stepEnd[0]]);
            
            // Calculate distance traveled in current step
            const stepDistance = currentStep.distance;
            const distanceTraveled = Math.max(0, stepDistance - distanceToStepEnd);
            const progressPercent = Math.min(100, (distanceTraveled / stepDistance) * 100);
            
            // Update progress bar
            document.getElementById('step-progress').style.width = `${progressPercent}%`;
            
            // Update distance display
            document.getElementById('nav-dist-next').innerText = 
                distanceToStepEnd < 1000 ? `In ${Math.round(distanceToStepEnd)}m` : `In ${(distanceToStepEnd/1000).toFixed(1)}km`;
            
            // Check if we've completed the current step
            if (distanceToStepEnd < 30) { // Within 30 meters of step end
                advanceToNextStep();
            }
            
            // Calculate remaining distance
            calculateRemainingDistance();
        }
        
        function checkNavigationProgressManually() {
            if (!isNavigating || !currentNavRoute || !currentNavRoute.steps || !userPos) return;
            
            const currentStep = currentNavRoute.steps[currentStepIndex];
            if (!currentStep) return;
            
            // Calculate remaining distance for current step (simulated)
            const remainingStepDistance = Math.max(0, currentStep.distance * (1 - (Math.random() * 0.1)));
            
            // Update progress
            const progressPercent = Math.min(100, ((currentStep.distance - remainingStepDistance) / currentStep.distance) * 100);
            document.getElementById('step-progress').style.width = `${progressPercent}%`;
            
            document.getElementById('nav-dist-next').innerText = 
                remainingStepDistance < 1000 ? `In ${Math.round(remainingStepDistance)}m` : `In ${(remainingStepDistance/1000).toFixed(1)}km`;
            
            // Simulate step completion (for demo - in real app this would use actual GPS)
            if (remainingStepDistance < 50 && currentStepIndex < currentNavRoute.steps.length - 1) {
                advanceToNextStep();
            }
            
            // Calculate remaining distance
            calculateRemainingDistance();
        }
        
        function getStepEndCoordinate(step) {
            if (step.geometry && step.geometry.coordinates && step.geometry.coordinates.length > 0) {
                const lastCoord = step.geometry.coordinates[step.geometry.coordinates.length - 1];
                return [lastCoord[1], lastCoord[0]]; // Convert to [lat, lng]
            }
            return null;
        }
        
        function advanceToNextStep() {
            if (!currentNavRoute || !currentNavRoute.steps) return;
            
            if (currentStepIndex < currentNavRoute.steps.length - 1) {
                currentStepIndex++;
                updateNavigationDisplay();
                
                // Update directions list highlighting
                updateDirectionsList();
            } else {
                // Reached destination
                completeNavigation();
            }
        }
        
        function calculateRemainingDistance() {
            if (!currentNavRoute || !currentNavRoute.steps) return;
            
            let remaining = 0;
            for (let i = currentStepIndex; i < currentNavRoute.steps.length; i++) {
                remaining += currentNavRoute.steps[i].distance || 0;
            }
            
            remainingDistance = remaining;
            document.getElementById('nav-remaining').innerText = 
                remaining < 1000 ? `${Math.round(remaining)}m` : `${(remaining/1000).toFixed(1)} km`;
        }
        
        function updateNavigationDisplay() {
            if (!currentNavRoute) return;
            
            const steps = currentNavRoute.steps || [];
            
            if (steps.length > 0 && currentStepIndex < steps.length) {
                const currentStep = steps[currentStepIndex];
                const nextStep = steps[currentStepIndex + 1];
                
                // Get instruction text
                const instructionText = currentStep.maneuver.instruction || "Continue on current route";
                
                // Update display
                document.getElementById('nav-instruction').innerHTML = instructionText;
                document.getElementById('nav-dist-next').innerText = 
                    currentStep.distance < 1000 ? `In ${Math.round(currentStep.distance)}m` : `In ${(currentStep.distance/1000).toFixed(1)}km`;
                
                // Reset progress bar
                document.getElementById('step-progress').style.width = '0%';
                
                // Update next turn if available
                if (nextStep) {
                    document.getElementById('nav-next-turn').innerText = 
                        nextStep.maneuver.instruction || "Continue straight";
                } else {
                    document.getElementById('nav-next-turn').innerText = "Final destination";
                }
                
                // Update ETA
                let remainingTime = 0;
                for (let i = currentStepIndex; i < steps.length; i++) {
                    remainingTime += steps[i].duration || 0;
                }
                
                const eta = getArrival(remainingTime);
                document.getElementById('nav-eta').innerText = eta;
                
                // Update icon based on maneuver type
                updateNavIcon(currentStep);
            } else {
                // Destination reached
                completeNavigation();
            }
        }
        
        function completeNavigation() {
            document.getElementById('nav-instruction').innerText = 
                "You have arrived at your destination";
            document.getElementById('nav-dist-next').innerText = "Arrived";
            document.getElementById('nav-next-turn').innerText = "Destination reached";
            document.getElementById('step-progress').style.width = '100%';
            document.getElementById('nav-eta').innerText = "Now";
            document.getElementById('nav-remaining').innerText = "0 m";
            
            // Stop navigation monitoring
            if (gpsWatchInterval) {
                clearInterval(gpsWatchInterval);
                gpsWatchInterval = null;
            }
        }
        
        function updateNavIcon(step) {
            const icon = document.getElementById('nav-step-icon');
            if (!step.maneuver) {
                icon.setAttribute('icon', 'lucide:navigation');
                return;
            }
            
            const maneuver = step.maneuver.type || '';
            const modifier = step.maneuver.modifier || '';
            
            if (maneuver.includes('arrive')) {
                icon.setAttribute('icon', 'lucide:flag');
            } else if (maneuver.includes('depart')) {
                icon.setAttribute('icon', 'lucide:map-pin');
            } else if (modifier.includes('left') || maneuver.includes('left')) {
                icon.setAttribute('icon', 'lucide:corner-up-left');
            } else if (modifier.includes('right') || maneuver.includes('right')) {
                icon.setAttribute('icon', 'lucide:corner-up-right');
            } else if (maneuver.includes('roundabout')) {
                icon.setAttribute('icon', 'lucide:repeat');
            } else if (maneuver.includes('fork')) {
                icon.setAttribute('icon', 'lucide:git-fork');
            } else if (maneuver.includes('merge')) {
                icon.setAttribute('icon', 'lucide:merge');
            } else if (maneuver.includes('exit') || maneuver.includes('off ramp')) {
                icon.setAttribute('icon', 'lucide:corner-right-down');
            } else {
                icon.setAttribute('icon', 'lucide:navigation');
            }
        }
        
        function updateDirectionsList() {
            const steps = document.querySelectorAll('.direction-step');
            steps.forEach((step, index) => {
                step.classList.remove('active', 'completed');
                if (index === currentStepIndex) {
                    step.classList.add('active');
                } else if (index < currentStepIndex) {
                    step.classList.add('completed');
                }
            });
        }
        
        // --- ENHANCED SEARCH WITH FILTERS ---
        async function performSearch(query) {
            if (!query || query.trim().length < 2) {
                showRecentSearches();
                return;
            }
            
            // Save to recents
            saveToRecentSearches(query);
            
            document.getElementById('search-spinner').classList.remove('hidden');
            document.getElementById('filters').classList.remove('hidden');
            
            try {
                let searchQuery = query;
                
                // Handle "near me" queries
                if (activeFilter === 'nearby' || query.toLowerCase().includes('near me')) {
                    if (userPos) {
                        const radius = 5000; // 5km radius
                        searchQuery = query.replace(/near me/gi, '').trim();
                        if (searchQuery) {
                            await performOverpassSearch(searchQuery);
                            return;
                        }
                    }
                }
                
                // Regular Photon search
                const response = await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(searchQuery)}&limit=15`);
                const data = await response.json();
                
                searchResults = data.features || [];
                applyFilter(activeFilter);
            } catch (error) {
                console.error("Search failed:", error);
                searchResults = [];
                displaySearchResults([]);
            } finally {
                document.getElementById('search-spinner').classList.add('hidden');
            }
        }
        
        async function performOverpassSearch(query) {
            if (!userPos) return;
            
            const [lat, lon] = userPos;
            const radius = 5000; // 5km in meters
            
            // Map query types to OSM tags
            const tagMap = {
                'hotels': 'tourism=hotel',
                'parks': 'leisure=park',
                'restaurants': 'amenity=restaurant',
                'gas': 'amenity=fuel',
                'coffee': 'amenity=cafe',
                'shopping': 'shop=*',
                'hospital': 'amenity=hospital'
            };
            
            let overpassQuery = `[out:json][timeout:25];(`;
            
            if (query in tagMap) {
                overpassQuery += `node[${tagMap[query]}](around:${radius},${lat},${lon});`;
                overpassQuery += `way[${tagMap[query]}](around:${radius},${lat},${lon});`;
                overpassQuery += `relation[${tagMap[query]}](around:${radius},${lat},${lon});`;
            } else {
                // General search
                overpassQuery += `node["name"~"${query}",i](around:${radius},${lat},${lon});`;
                overpassQuery += `way["name"~"${query}",i](around:${radius},${lat},${lon});`;
                overpassQuery += `relation["name"~"${query}",i](around:${radius},${lat},${lon});`;
            }
            
            overpassQuery += `);out body;>;out skel qt;`;
            
            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: overpassQuery
                });
                const data = await response.json();
                
                // Convert OSM data to our format
                searchResults = data.elements.map(element => {
                    const tags = element.tags || {};
                    return {
                        type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: [element.lon || element.center?.lon, element.lat || element.center?.lat]
                        },
                        properties: {
                            name: tags.name || `Unnamed ${query}`,
                            type: query,
                            distance: map.distance(userPos, [element.lat || element.center?.lat, element.lon || element.center?.lon])
                        }
                    };
                });
                
                // Sort by distance
                searchResults.sort((a, b) => a.properties.distance - b.properties.distance);
                
                displaySearchResults(searchResults);
            } catch (error) {
                console.error("Overpass search failed:", error);
                // Fall back to regular search
                const response = await fetch(`https://photon.komoot.io/api/?q=${encodeURIComponent(query)}+near+me&limit=15`);
                const data = await response.json();
                searchResults = data.features || [];
                applyFilter(activeFilter);
            }
        }
        
        function saveToRecentSearches(query) {
            const recent = {
                query: query,
                timestamp: new Date().toISOString(),
                timeText: 'Just now'
            };
            
            // Remove if already exists
            recentSearches = recentSearches.filter(item => item.query !== query);
            
            // Add to beginning
            recentSearches.unshift(recent);
            
            // Keep only last 10
            recentSearches = recentSearches.slice(0, 10);
            
            // Update time texts
            updateRecentTimes();
            
            // Save to localStorage
            localStorage.setItem('strikeRecentSearches', JSON.stringify(recentSearches));
        }
        
        function updateRecentTimes() {
            const now = new Date();
            recentSearches.forEach(item => {
                const itemTime = new Date(item.timestamp);
                const diffMinutes = Math.floor((now - itemTime) / (1000 * 60));
                
                if (diffMinutes < 1) item.timeText = 'Just now';
                else if (diffMinutes < 60) item.timeText = `${diffMinutes}m ago`;
                else if (diffMinutes < 1440) item.timeText = `${Math.floor(diffMinutes/60)}h ago`;
                else item.timeText = `${Math.floor(diffMinutes/1440)}d ago`;
            });
        }
        
        function showRecentSearches() {
            updateRecentTimes();
            const container = document.getElementById('results');
            const filters = document.getElementById('filters');
            
            if (recentSearches.length === 0) {
                container.classList.add('hidden');
                filters.classList.add('hidden');
                return;
            }
            
            filters.classList.remove('hidden');
            
            let html = `
                <div class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest mb-2">Recent Searches</div>
            `;
            
            recentSearches.forEach((recent, index) => {
                html += `
                    <div class="recent-item" data-query="${recent.query}">
                        <div class="flex justify-between items-center">
                            <div class="text-[11px] font-semibold text-white">${recent.query}</div>
                            <div class="recent-time">${recent.timeText}</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            container.classList.remove('hidden');
            
            // Add click handlers
            document.querySelectorAll('.recent-item').forEach(item => {
                item.addEventListener('click', () => {
                    const query = item.dataset.query;
                    document.getElementById('search-input').value = query;
                    performSearch(query);
                });
            });
        }
        
        function applyFilter(filter) {
            activeFilter = filter;
            
            // Update filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.filter === filter) {
                    btn.classList.add('active');
                }
            });
            
            let filteredResults = searchResults;
            
            if (filter !== 'all' && filter !== 'nearby') {
                filteredResults = searchResults.filter(result => {
                    const props = result.properties;
                    const name = props.name?.toLowerCase() || '';
                    const type = props.type?.toLowerCase() || '';
                    
                    switch(filter) {
                        case 'hotels':
                            return name.includes('hotel') || name.includes('inn') || name.includes('motel') || 
                                   type.includes('hotel') || props.tourism === 'hotel';
                        case 'parks':
                            return name.includes('park') || name.includes('garden') || 
                                   type.includes('park') || props.leisure === 'park';
                        case 'restaurants':
                            return name.includes('restaurant') || name.includes('cafe') || name.includes('diner') || 
                                   type.includes('restaurant') || props.amenity === 'restaurant';
                        case 'gas':
                            return name.includes('gas') || name.includes('fuel') || name.includes('station') ||
                                   type.includes('fuel') || props.amenity === 'fuel';
                        default:
                            return true;
                    }
                });
            }
            
            displaySearchResults(filteredResults);
        }
        
        function getLocationType(properties) {
            if (properties.type === 'city' || properties.city) return 'city';
            if (properties.type === 'street' || properties.street) return 'street';
            if (properties.type === 'building' || properties.housenumber) return 'building';
            if (properties.type === 'landmark' || properties.name?.match(/(Park|Museum|Station|Airport|Plaza|Square)/i)) return 'landmark';
            return 'default';
        }
        
        function getTypeBadge(type) {
            const badges = {
                'city': '<span class="type-badge type-city">City</span>',
                'street': '<span class="type-badge type-street">Street</span>',
                'building': '<span class="type-badge type-building">Building</span>',
                'landmark': '<span class="type-badge type-landmark">Landmark</span>',
                'default': '<span class="type-badge type-default">Location</span>'
            };
            return badges[type] || badges.default;
        }
        
        function displaySearchResults(results) {
            const container = document.getElementById('results');
            container.innerHTML = '';
            
            if (results.length === 0) {
                container.innerHTML = '<div class="text-xs text-neutral-500 p-4 text-center">No results found</div>';
                container.classList.remove('hidden');
                return;
            }
            
            results.forEach((result) => {
                const div = document.createElement('div');
                div.className = 'search-result';
                
                const props = result.properties;
                const type = getLocationType(props);
                const badge = getTypeBadge(type);
                
                const name = props.name || props.street || props.city || "Unnamed Location";
                let details = [props.housenumber, props.street, props.city, props.country]
                    .filter(Boolean)
                    .join(', ');
                
                // Add distance if available
                if (props.distance) {
                    const dist = props.distance < 1000 ? 
                        `${Math.round(props.distance)}m away` : 
                        `${(props.distance/1000).toFixed(1)}km away`;
                    details = details ? `${details} • ${dist}` : dist;
                }
                
                div.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <div class="text-[11px] font-bold text-white">${name}</div>
                        ${badge}
                    </div>
                    <div class="text-[9px] text-neutral-400">${details || 'Coordinates'}</div>
                `;
                
                div.onclick = () => {
                    const [lng, lat] = result.geometry.coordinates;
                    map.flyTo([lat, lng], 15, { animate: true, duration: 1 });
                    triggerAnalysis(lat, lng);
                    hideSearchResults();
                    document.getElementById('search-input').value = name;
                };
                
                container.appendChild(div);
            });
            
            container.classList.remove('hidden');
        }
        
        function hideSearchResults() {
            document.getElementById('results').classList.add('hidden');
            document.getElementById('filters').classList.add('hidden');
        }
        
        // --- UTILITIES ---
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m`;
            } else {
                return '<1m';
            }
        }
        
        function getArrival(seconds) {
            const now = new Date();
            const arrival = new Date(now.getTime() + seconds * 1000);
            return arrival.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }
        
        function closeSidebar() { 
            document.getElementById('info-sidebar').classList.remove('active'); 
            routeLayer.clearLayers(); 
            currentRoute = null;
            currentNavRoute = null;
            isNavigating = false;
            
            // Stop navigation monitoring
            if (gpsWatchInterval) {
                clearInterval(gpsWatchInterval);
                gpsWatchInterval = null;
            }
            
            // Reset sidebar content
            const content = document.getElementById('sidebar-content');
            content.innerHTML = `
                <div id="logistics-module">
                    <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block mb-4">Routes via Engine</span>
                    <div id="route-options" class="flex flex-col gap-2"></div>
                </div>
                <div class="space-y-2">
                    <span class="text-[9px] font-bold text-neutral-500 uppercase tracking-widest block">Address</span>
                    <p id="side-address" class="text-xs text-neutral-400 leading-relaxed">Calculating coordinates...</p>
                </div>
            `;
        }
        
        function recenterMap() {
            if (userPos) {
                map.flyTo(userPos, 14, { animate: true, duration: 1 });
                userMarker.setLatLng(userPos);
            }
        }
        
        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {
            // Search input
            const searchInput = document.getElementById('search-input');
            let searchTimeout;
            
            searchInput.addEventListener('focus', () => {
                showRecentSearches();
            });
            
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                if (!e.target.value.trim()) {
                    showRecentSearches();
                    return;
                }
                searchTimeout = setTimeout(() => {
                    performSearch(e.target.value);
                }, 300);
            });
            
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideSearchResults();
                }
            });
            
            // Filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const filter = e.target.dataset.filter;
                    applyFilter(filter);
                    
                    // If there's search text, re-search with filter
                    if (searchInput.value.trim()) {
                        performSearch(searchInput.value);
                    }
                });
            });
            
            // Locate button
            document.getElementById('locate-btn').addEventListener('click', recenterMap);
            
            // Satellite toggle
            document.getElementById('sat-toggle').addEventListener('click', () => {
                if (map.hasLayer(satLayer)) {
                    map.removeLayer(satLayer);
                } else {
                    satLayer.addTo(map);
                }
            });
            
            // Zoom buttons
            document.getElementById('zoom-in').addEventListener('click', () => {
                map.zoomIn();
            });
            
            document.getElementById('zoom-out').addEventListener('click', () => {
                map.zoomOut();
            });
            
            // Exit navigation button
            document.getElementById('exit-nav-btn').addEventListener('click', () => {
                isNavigating = false;
                document.getElementById('standard-ui').style.display = 'flex';
                document.getElementById('active-nav-hud').style.display = 'none';
                closeSidebar();
            });
            
            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                const searchContainer = document.querySelector('.strike-glass.p-2');
                const results = document.getElementById('results');
                
                if (searchContainer && results && !searchContainer.contains(e.target) && 
                    e.target !== searchInput) {
                    hideSearchResults();
                }
            });
            
            // Manual step advancement (for testing)
            document.addEventListener('keydown', (e) => {
                if (isNavigating && e.key === ' ') {
                    e.preventDefault();
                    advanceToNextStep();
                }
            });
        });
        
        // Clean up GPS watch on page unload
        window.addEventListener('beforeunload', () => {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
            }
            if (gpsWatchInterval) {
                clearInterval(gpsWatchInterval);
            }
        });
    </script>
</body>
</html>
